#ifndef lint
static const char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif

#include <stdlib.h>
#include <string.h>

#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYPATCH 20070509

#define YYEMPTY (-1)
#define yyclearin    (yychar = YYEMPTY)
#define yyerrok      (yyerrflag = 0)
#define YYRECOVERING (yyerrflag != 0)

extern int yyparse(void);

static int yygrowstack(void);
#define YYPREFIX "yy"
#line 2 "../gram.y"
/*
 *  R : A Computer Langage for Statistical Data Analysis
 *  Copyright (C) 1995, 1996, 1997  Robert Gentleman and Ross Ihaka
 *  Copyright (C) 1997--2008  Robert Gentleman, Ross Ihaka and the
 *                            R Development Core Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, a copy is available at
 *  http://www.r-project.org/Licenses/
 */

/* #include <IOStuff.h> */
/* #include <Fileio.h> */

#include <R_ext/Parse.h>
extern0 int	R_ParseContextLast INI_as(0); /* last character in context buffer */
#define YYERROR_VERBOSE 1

static void yyerror(char *);
static int yylex();
int yyparse(void);

/* alloca.h inclusion is now covered by Defn.h */

#define yyconst const

typedef struct yyltype
{
  int first_line;
  int first_column;
  int first_byte;

  int last_line;
  int last_column;
  int last_byte;
} yyltype;

# define YYLTYPE yyltype
# define YYLLOC_DEFAULT(Current, Rhs, N)				\
    do									\
      if (YYID (N))							\
	{								\
	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
	  (Current).first_byte   = YYRHSLOC (Rhs, 1).first_byte;	\
	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
	  (Current).last_byte    = YYRHSLOC (Rhs, N).last_byte;		\
	}								\
      else								\
	{								\
	  (Current).first_line   = (Current).last_line   =		\
	    YYRHSLOC (Rhs, 0).last_line;				\
	  (Current).first_column = (Current).last_column =		\
	    YYRHSLOC (Rhs, 0).last_column;				\
	  (Current).first_byte   = (Current).last_byte =		\
	    YYRHSLOC (Rhs, 0).last_byte;				\
	}								\
    while (YYID (0))

/* Useful defines so editors don't get confused ... */

#define LBRACE	'{'
#define RBRACE	'}'

/* Functions used in the parsing process */

static void	CheckFormalArgs(SEXP, SEXP, YYLTYPE *);
static SEXP	FirstArg(SEXP, SEXP);
static SEXP	GrowList(SEXP, SEXP);
static SEXP	Insert(SEXP, SEXP);
static void	IfPush(void);
static int	KeywordLookup(const char *);
static SEXP	NewList(void);
static SEXP	NextArg(SEXP, SEXP, SEXP);
static SEXP	TagArg(SEXP, SEXP, YYLTYPE *);


/* Internal lexer / parser state variables */

static int	EatLines = 0;
static int	GenerateCode = 0;
static int	EndOfFile = 0;
static int	xxgetc();
static int	xxungetc(int);
static int	xxcharcount, xxcharsave;
static int	xxlineno, xxbyteno, xxcolno,  xxlinesave, xxbytesave, xxcolsave;

static SEXP     SrcFile = NULL;
static SEXP	SrcRefs = NULL;
static PROTECT_INDEX srindex;

#if defined(SUPPORT_MBCS)
/* # include <R_ext/rlocale.h> */ 
#ifdef HAVE_LANGINFO_CODESET
# include <langinfo.h>
#endif


static int mbcs_get_next(int c, wchar_t *wc)
{
    int i, res, clen = 1; char s[9];
    mbstate_t mb_st;

    s[0] = c;
    /* This assumes (probably OK) that all MBCS embed ASCII as single-byte
       lead bytes, including control chars */
    if((unsigned int) c < 0x80) {
	*wc = (wchar_t) c;
	return 1;
    }
    if(utf8locale) {
	clen = utf8clen(c);
	for(i = 1; i < clen; i++) {
	    s[i] = xxgetc();
	    if(s[i] == R_EOF) error(_("EOF whilst reading MBCS char at line %d"), xxlineno);
	}
	res = mbrtowc(wc, s, clen, NULL);
	if(res == -1) error(_("invalid multibyte character in parser at line %d"), xxlineno);
    } else {
	/* This is not necessarily correct for stateful MBCS */
	while(clen <= MB_CUR_MAX) {
	    mbs_init(&mb_st);
	    res = mbrtowc(wc, s, clen, &mb_st);
	    if(res >= 0) break;
	    if(res == -1)
		error(_("invalid multibyte character in parser at line %d"), xxlineno);
	    /* so res == -2 */
	    c = xxgetc();
	    if(c == R_EOF) error(_("EOF whilst reading MBCS char at line %d"), xxlineno);
	    s[clen++] = c;
	} /* we've tried enough, so must be complete or invalid by now */
    }
    for(i = clen - 1; i > 0; i--) xxungetc(s[i]);
    return clen;
}

#endif

/* Handle function source */

#define MAXFUNSIZE 131072
#define MAXNEST       265

static unsigned char FunctionSource[MAXFUNSIZE];
static unsigned char *FunctionStart[MAXNEST], *SourcePtr;
static int FunctionLevel = 0;
static int KeepSource;

/* Soon to be defunct entry points */

void		R_SetInput(int);
int		R_fgetc(FILE*);

/* Routines used to build the parse tree */

static SEXP	xxnullformal(void);
static SEXP	xxfirstformal0(SEXP);
static SEXP	xxfirstformal1(SEXP, SEXP);
static SEXP	xxaddformal0(SEXP, SEXP, YYLTYPE *);
static SEXP	xxaddformal1(SEXP, SEXP, SEXP, YYLTYPE *);
static SEXP	xxexprlist0();
static SEXP	xxexprlist1(SEXP, YYLTYPE *);
static SEXP	xxexprlist2(SEXP, SEXP, YYLTYPE *);
static SEXP	xxsub0(void);
static SEXP	xxsub1(SEXP, YYLTYPE *);
static SEXP	xxsymsub0(SEXP, YYLTYPE *);
static SEXP	xxsymsub1(SEXP, SEXP, YYLTYPE *);
static SEXP	xxnullsub0(YYLTYPE *);
static SEXP	xxnullsub1(SEXP, YYLTYPE *);
static SEXP	xxsublist1(SEXP);
static SEXP	xxsublist2(SEXP, SEXP);
static SEXP	xxcond(SEXP);
static SEXP	xxifcond(SEXP);
static SEXP	xxif(SEXP, SEXP, SEXP);
static SEXP	xxifelse(SEXP, SEXP, SEXP, SEXP);
static SEXP	xxforcond(SEXP, SEXP);
static SEXP	xxfor(SEXP, SEXP, SEXP);
static SEXP	xxwhile(SEXP, SEXP, SEXP);
static SEXP	xxrepeat(SEXP, SEXP);
static SEXP	xxnxtbrk(SEXP);
static SEXP	xxfuncall(SEXP, SEXP);
static SEXP	xxdefun(SEXP, SEXP, SEXP);
static SEXP	xxunary(SEXP, SEXP);
static SEXP	xxbinary(SEXP, SEXP, SEXP);
static SEXP	xxparen(SEXP, SEXP);
static SEXP	xxsubscript(SEXP, SEXP, SEXP);
static SEXP	xxexprlist(SEXP, YYLTYPE *, SEXP);
static int	xxvalue(SEXP, int, YYLTYPE *);

#define YYSTYPE		SEXP

#line 226 "y.tab.c"
#define END_OF_INPUT 257
#define ERROR 258
#define STR_CONST 259
#define NUM_CONST 260
#define NULL_CONST 261
#define SYMBOL 262
#define FUNCTION 263
#define LEFT_ASSIGN 264
#define EQ_ASSIGN 265
#define RIGHT_ASSIGN 266
#define LBB 267
#define FOR 268
#define IN 269
#define IF 270
#define ELSE 271
#define WHILE 272
#define NEXT 273
#define BREAK 274
#define REPEAT 275
#define GT 276
#define GE 277
#define LT 278
#define LE 279
#define EQ 280
#define NE 281
#define AND 282
#define OR 283
#define AND2 284
#define OR2 285
#define NS_GET 286
#define NS_GET_INT 287
#define LOW 288
#define TILDE 289
#define UNOT 290
#define NOT 291
#define SPECIAL 292
#define UMINUS 293
#define UPLUS 294
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,    0,    0,    0,    1,    1,    3,    2,    2,
    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
    2,    2,    2,    2,   10,    8,    9,    4,    4,    4,
    4,    4,    4,    7,    7,   11,   11,   11,   11,   11,
   11,   11,   11,    5,    5,    5,    5,    5,    6,
};
short yylen[] = {                                         2,
    1,    1,    2,    2,    1,    1,    1,    3,    1,    1,
    1,    1,    3,    3,    2,    2,    2,    2,    2,    3,
    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
    3,    6,    4,    3,    5,    3,    3,    2,    5,    4,
    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
    3,    3,    1,    1,    3,    3,    5,    0,    1,    3,
    2,    3,    2,    1,    4,    0,    1,    2,    3,    2,
    3,    2,    3,    0,    1,    3,    3,    5,    0,
};
short yydefred[] = {                                      0,
    5,    1,    0,    9,   11,    0,    0,    0,    0,    0,
   63,   64,    0,    0,    0,    0,    0,    0,    2,    0,
    0,    0,    0,    0,    7,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   48,    0,    0,    0,
    0,    0,   69,    0,    0,    3,    4,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   54,   53,   58,   57,   52,
   51,   56,   55,    0,    0,    0,   46,    0,    0,    0,
   47,   14,    0,    0,   13,    0,    8,    0,    0,    0,
    0,    0,    0,   74,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   60,   59,   62,   61,    0,    0,    0,
    0,   89,    0,    0,   66,    0,   65,   72,   70,    0,
    0,    0,    0,    0,   43,   50,    0,    0,    0,    0,
   45,    0,    0,    0,   49,    0,   42,    0,   67,   75,
    0,
};
short yydgoto[] = {                                      22,
   23,   24,   25,   44,   85,  144,  103,   34,   32,   36,
  104,
};
short yysindex[] = {                                    947,
    0,    0, -271,    0,    0, -242,  -30,  -20,   11,   17,
    0,    0, 1913, 1913, 1913, 1913, 1913, 1913,    0, 1913,
 1913,    0,   -4, 1423,    0, -255, -245, -238, -220, -184,
 -182, 1913, 1913, 1913, 1913, 1913,    0, 1806, 1846,  -28,
  -28,   48,    0,   -7, 1886,    0,    0, 1913, 1913, 1913,
 1930, 1913, 1913, 1913, 1913, 1913, 1913, 1913, 1913, 1913,
 1913, 1913, 1913, 1913, 1913, 1913, 1913, 1913, 1913, 1913,
 -201, -174, 1930, 1930, 1913,    0,    0,    0,    0,    0,
    0,    0,    0, -169,   53, -171,    0, 1452, -159, 1493,
    0,    0, 1913, 1913,    0, 1806,    0, 1826, -246, -165,
 -109, 1750,   30,    0,  855,  855,  855,  855,  855,  855,
 1886, 1866, 1886, 1866, 1806, 1846,  431,  431,  580,  580,
  -35,  -28,  -28,    0,    0,    0,    0,   86,   41, 1750,
 1913,    0, -124, 1913,    0, 1913,    0,    0,    0, 1913,
 1913, 1913,   73,  137,    0,    0, 1750, 1913,  -78, 1553,
    0, 1750, 1750, 1750,    0, 1930,    0, 1913,    0,    0,
 1750,
};
short yyrindex[] = {                                      0,
    0,    0,  -10,    0,    0,   28,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
    0,    0,    0,  154,    0,    0,    0,    0,    0,   76,
    0,    0,    0,    0,    0,    0,    0,  155,  499,  104,
  127,    0,    0,    0,  586,    0,    0,    0,    0,    0,
  -16,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   99,  -16,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  117,    0,    0,    0,    0,   66,    0,
    0,    0,    3,    8,    0, 1202,    0, 1182, 1288, 1348,
 1386,  -19,  145,    0,  736,  822,  845,  868,  891,  915,
  965, 1015,  988, 1038, 1225, 1102,  536,  559,  472,  508,
  449,  165,  411,    0,    0,    0,    0,  145,  145,   91,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    2,
    6,   38,    0,    0,    0,    0,  132,    0,  138,    0,
    0,   49,   95,  100,    0,  111,    0,    0,    0,    0,
  139,
};
short yygindex[] = {                                      0,
  623, 2180,    0,    0,    0,   62,   31,    0,    0,    0,
   44,
};
#define YYTABLESIZE 2338
short yytable[] = {                                      10,
   71,   75,   93,   76,   73,   46,   77,   71,   75,   30,
   68,   73,   73,   78,   26,   27,   79,   71,  140,   31,
   80,   77,   69,   81,   77,   10,   10,   76,   72,   10,
   10,   10,   10,   10,   10,   72,   10,   12,   82,   26,
   27,   83,   80,   28,   29,   80,   82,   10,   10,   82,
   33,   94,   10,   10,   47,   74,   35,  124,   70,   68,
  125,   73,   74,   12,   12,   70,   71,   12,   12,   12,
   12,   12,   12,   77,   12,   44,   76,   84,   78,   86,
   10,   78,   10,   10,  126,   12,   12,  127,   92,   81,
   12,   12,   81,  132,   80,  131,  133,  134,   82,  141,
   27,   44,   44,  128,  129,   44,   44,   44,   44,   44,
   44,  136,   44,   16,   10,   10,   84,   95,   12,   84,
   12,   12,  143,   44,   44,   68,  145,   73,   44,   44,
   78,   27,   71,  146,   27,   83,   15,  149,   83,   76,
   79,   81,   76,   79,   16,   16,   16,   16,   16,   27,
   16,   76,   12,   12,   76,  142,   44,   85,   44,   44,
   85,   16,   16,    6,   19,  155,   16,   15,   15,   15,
   15,   15,   86,   15,   20,   86,   28,   29,   87,   88,
  156,   87,   88,   27,   15,   15,  158,   83,   89,   15,
   44,   44,   79,  148,    6,   19,   16,    6,   19,  160,
    0,    0,    0,   76,    0,   20,   20,   20,   20,   20,
    0,   20,    6,   19,    0,   27,    0,   19,    0,   15,
    0,    0,   20,   20,    0,    0,    0,   20,   16,   16,
    0,   51,    0,    0,    0,    0,    0,    0,   51,    0,
    0,    0,    0,    0,    0,    0,    6,   19,    0,    0,
    0,   15,   15,   10,   10,   10,   10,   20,    0,    0,
   10,    0,    0,    0,    0,   10,   10,   10,   10,   10,
   10,   10,   10,   10,   10,    0,    0,    0,    6,   19,
    0,   10,    0,    0,    0,    0,    0,    0,    0,   20,
   20,   12,   12,   12,   12,    0,    0,    0,   12,    0,
    0,    0,    0,   12,   12,   12,   12,   12,   12,   12,
   12,   12,   12,    0,    0,    0,    0,    0,    0,   12,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   44,
   44,   44,   44,    0,    0,    0,    0,    0,    0,    0,
    0,   44,   44,   44,   44,   44,   44,   44,   44,   44,
   44,    0,    0,    0,    0,   27,    0,   44,    0,    0,
    0,   27,    0,    0,    0,    0,    0,   16,   16,   16,
    0,    0,    0,    0,   16,    0,    0,    0,    0,   16,
   16,   16,   16,   16,   16,   16,   16,   16,   16,    0,
   15,   15,   15,    0,    0,   16,    0,   15,    0,    0,
    0,    0,   15,   15,   15,   15,   15,   15,   15,   15,
   15,   15,    0,    0,    0,    0,    0,    0,   15,   19,
   25,    0,    0,    0,    6,   19,    0,    0,   20,   20,
   20,    0,    0,    0,    0,   20,    0,    0,    0,    0,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
    0,   25,   25,   25,   25,   25,   20,   25,   26,    0,
    0,    0,    0,    0,    0,    0,   71,   75,   25,   25,
   73,    0,   66,   25,    0,    0,    0,   67,    0,    0,
    0,   23,    0,    0,    0,    0,    0,    0,   69,   26,
   26,   26,   26,   26,   72,   26,    0,    0,    0,    0,
    0,    0,    0,   25,    0,    0,    0,   26,   18,    0,
    0,   26,   23,   23,   23,   23,   23,   24,   23,    0,
    0,   74,    0,    0,   70,    0,    0,    0,    0,    0,
   23,    0,    0,    0,   23,   25,   25,    0,    0,   18,
    0,   26,   18,    0,    0,   21,    0,    0,   24,   24,
   24,   24,   24,    0,   24,    0,    0,   18,    0,    0,
    0,   18,    0,    0,   23,    0,   24,    0,   22,    0,
   24,    0,    0,   26,   26,    0,   21,    0,   21,   21,
   21,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   18,    0,    0,   21,   17,   23,   23,   21,   22,
   24,   22,   22,   22,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   71,   75,   22,    0,   73,
    0,   22,    0,   18,   18,    0,   17,    0,   21,   17,
    0,    0,   24,   24,    0,   37,    0,   69,    0,    0,
   42,    0,   43,   72,   17,    0,    0,    0,   17,    0,
    0,   22,    0,    0,   87,    0,   89,    0,   91,    0,
   21,   21,    0,    0,    0,    0,    0,    0,    0,    0,
   74,   97,    0,   70,   25,   25,   25,    0,   17,    0,
    0,   25,    0,   22,   22,    0,   25,   25,   25,   25,
   25,   25,   25,   25,   25,   25,    0,   51,    0,    0,
    0,    0,   25,    0,    0,    0,    0,    0,    0,    0,
   17,   17,   26,   26,   26,  138,  139,    0,    0,   26,
    0,    0,   68,    0,   26,   26,   26,   26,   26,   26,
   26,   26,   26,   26,    0,   23,   23,   23,    0,    0,
   26,    0,   23,    0,    0,   35,    0,   23,   23,   23,
   23,   23,   23,   23,   23,   23,   23,    0,  151,    0,
    0,    0,   18,   18,   18,    0,    0,    0,    0,   18,
  157,   24,   24,   24,    0,    0,   35,    0,   24,   35,
    0,    0,    0,   24,   24,   24,   24,   24,   24,   24,
   24,   24,   24,    0,   35,    0,    0,    0,   35,   21,
   21,   21,    0,    0,    0,    0,   21,    0,    0,    0,
    0,   21,   21,   21,   21,   21,   21,   21,   21,   21,
   21,    0,   22,   22,   22,    0,    0,    0,   35,   22,
    0,   34,    0,    0,   22,   22,   22,   22,   22,   22,
   22,   22,   22,   22,    0,    0,   51,    0,    0,   17,
   17,   17,    0,    0,   30,    0,   17,    0,    0,    0,
   35,   35,   34,    0,    0,   34,    0,   17,   17,   17,
   17,   68,    0,    0,    0,    0,    0,   31,    0,    0,
   34,    0,    0,    0,   34,   30,    0,    0,   30,    0,
   71,   75,    0,    0,   73,    0,   66,   64,    0,   65,
   32,   67,    0,   30,    0,    0,    0,   30,   31,    0,
    0,   31,   69,    0,   34,    0,    0,    0,   72,    0,
    0,    0,    0,    0,   33,    0,   31,    0,    0,    0,
   31,   32,    0,    0,   32,    0,    0,   30,    0,    0,
    0,    0,    0,    0,    0,   74,   34,   34,   70,   32,
    0,    0,    0,   32,    0,   33,   19,    0,   33,    0,
   31,    0,    0,    0,    0,    0,    0,    0,    0,   30,
   30,    0,    0,   33,   36,    0,    0,   33,    0,   21,
    0,    0,    0,   32,    0,    0,   18,    0,    0,   16,
    0,   17,   31,   31,    0,    0,    0,   38,    0,   35,
   35,   35,    0,    0,    0,   36,   35,   33,   36,   14,
    0,    0,    0,    0,    0,   32,   32,   35,   35,   35,
   35,    0,    0,   36,   37,    0,    0,   36,   38,    0,
    0,   38,    0,    0,    0,    0,    0,    0,    0,   33,
   33,    0,    0,    0,    0,    0,   38,   39,    0,    0,
   38,    0,    0,    0,    0,   37,    0,   36,   37,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   20,
    0,    0,   15,   37,    0,    0,    0,   37,   39,    0,
   38,   39,    0,    0,    0,   34,   34,   34,    0,   36,
   36,    0,   34,    0,    0,    0,   39,    0,    0,    0,
   39,    0,    0,   34,   34,   34,   34,   37,   30,   30,
   30,   28,   38,   38,    0,   30,    0,    0,    0,    0,
    0,   51,    0,    0,    0,    0,   30,   30,   30,   30,
   39,   31,   31,   31,    0,    0,    0,    0,   31,   37,
   37,    0,   28,    0,    0,   28,   68,    0,    0,   31,
   31,   31,   31,    0,   32,   32,   32,    0,    0,    0,
   28,   32,   39,   39,   28,    0,    0,    0,    0,    0,
    0,    0,   32,   32,   32,   32,    0,    0,   33,   33,
   33,    0,    0,    0,    0,   33,    0,    0,    0,    0,
    0,   41,    0,    0,   28,    0,   33,   33,   33,   33,
    0,    0,    1,    2,    0,    3,    4,    5,    6,    7,
    0,   40,    0,    0,    8,    0,    9,    0,   10,   11,
   12,   13,   41,    0,    0,   41,   28,   28,   36,   36,
   36,    0,    0,    0,   29,   36,    0,    0,    0,    0,
   41,    0,   40,    0,   41,   40,   36,   36,   36,   36,
    0,   38,   38,   38,    0,    0,    0,    0,   38,    0,
   40,    0,    0,    0,   40,   29,    0,    0,   29,   38,
   38,   38,   38,    0,   41,    0,    0,    0,   37,   37,
   37,    0,    0,   29,    0,   37,    0,   29,    0,    0,
    0,    0,    0,    0,   40,    0,    0,   37,    0,   37,
    0,   39,   39,   39,    0,    0,   41,    0,   39,    0,
    0,    0,    0,    0,    0,    0,    0,   29,    0,    0,
   39,    0,   39,   10,   10,    0,   40,   10,   10,   10,
   10,   10,   10,    0,   10,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   10,    0,    0,    0,   29,
   10,   10,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   28,   28,   28,    0,    0,
    0,    0,   28,    0,    0,    0,    0,    0,   10,    0,
   10,   10,    0,   11,   11,    0,    0,   11,   11,   11,
   11,   11,   11,    0,   11,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   11,    0,    0,    0,    0,
   11,   11,    0,   10,    0,    0,    0,    0,    0,    0,
    0,   12,   12,    0,    0,   12,   12,   12,   12,   12,
   12,    0,   12,    0,    0,    0,    0,    0,   11,    0,
   11,   11,    0,   12,    0,   41,   41,   41,   12,   12,
    0,    0,   41,    0,    0,    0,    0,    0,   71,   75,
    0,    0,   73,    0,   66,   64,   40,   65,    0,   67,
    0,    0,   40,   11,    0,    0,   12,    0,   12,   12,
   69,    0,    0,    0,    0,   62,   72,   71,   75,   29,
    0,   73,  135,   66,   64,   29,   65,    0,   67,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   69,
    0,   12,    0,   74,   62,   72,   70,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   71,   75,
    0,    0,   73,  137,   66,   64,    0,   65,    0,   67,
    0,    0,   74,    0,    0,   70,    0,    0,   63,    0,
   69,   10,    0,   10,   10,   62,   72,    0,    0,    0,
    0,    0,    0,   10,   10,   10,   10,   10,   10,   10,
   10,   10,   10,    0,    0,    0,    0,   63,    0,   10,
    0,    0,    0,   74,    0,    0,   70,    0,   71,   75,
    0,    0,   73,  159,   66,   64,    0,   65,    0,   67,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   69,   11,    0,   11,   11,   62,   72,    0,   63,    0,
    0,    0,    0,   11,   11,   11,   11,   11,   11,   11,
   11,   11,   11,    0,    0,    0,    0,    0,    0,   11,
    0,    0,    0,   74,    0,    0,   70,    0,    0,   12,
    0,   12,   12,    0,    0,    0,    0,    0,    0,    0,
    0,   12,   12,   12,   12,   12,   12,   12,   12,   12,
   12,    0,    0,    0,    0,    0,    0,   12,   63,    0,
    0,    0,    0,    0,    0,    0,   48,   49,   50,   51,
    0,    0,    0,    0,    0,    0,    0,    0,   52,   53,
   54,   55,   56,   57,   58,   59,   60,   61,    0,    0,
    0,    0,    0,    0,   68,   48,    0,   50,   51,    0,
    0,    0,    0,    0,    0,    0,    0,   52,   53,   54,
   55,   56,   57,   58,   59,   60,   61,    0,    0,    0,
    0,    0,    0,   68,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   48,    0,   50,   51,
    0,    0,    0,    0,    0,    0,    0,    0,   52,   53,
   54,   55,   56,   57,   58,   59,   60,   61,    0,    0,
    0,    0,    0,    0,   68,   71,   75,    0,    0,   73,
    0,   66,   64,    0,   65,    0,   67,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   69,    0,    0,
    0,    0,   62,   72,    0,    0,   48,    0,   50,   51,
    0,    0,    0,    0,    0,    0,    0,    0,   52,   53,
   54,   55,   56,   57,   58,   59,   60,   61,    0,    0,
   74,   71,   75,   70,   68,   73,    0,   66,   64,    0,
   65,    0,   67,    0,    0,    0,    0,    0,    0,    0,
    0,   71,   75,   69,    0,   73,    0,   66,   64,   72,
   65,    0,   67,    0,    0,   63,    0,    0,    0,    0,
    0,   71,   75,   69,    0,   73,    0,   66,   64,   72,
   65,    0,   67,    0,    0,    0,   74,    0,    0,   70,
    0,   71,   75,   69,    0,   73,    0,   66,   64,   72,
   65,    0,   67,    0,    0,    0,   74,    0,    0,   70,
    0,   71,   75,   69,    0,   73,    0,   66,   64,   72,
   65,   63,   67,    0,    0,    0,   74,    0,    0,   70,
    0,    0,    0,   69,    0,   21,    0,    0,    0,   72,
    0,   63,   18,    0,    0,   16,   74,   17,    0,   70,
    0,    0,   21,    0,    0,    0,    0,    0,    0,   18,
    0,    0,   16,    0,   17,   14,   74,    0,    0,   70,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   14,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   48,    0,   50,   51,    0,    0,    0,
    0,    0,    0,    0,    0,   52,   53,   54,   55,   56,
   57,   58,   59,   60,   61,   20,    0,    0,   15,    0,
    0,   68,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   20,    0,    0,   15,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   48,
    0,   50,   51,    0,    0,    0,    0,    0,    0,    0,
    0,   52,   53,   54,   55,   56,   57,   58,   59,   60,
   61,    0,   51,    0,    0,    0,    0,   68,    0,    0,
    0,   52,   53,   54,   55,   56,   57,   58,   59,   60,
   61,    0,   51,    0,    0,    0,    0,   68,    0,    0,
    0,   52,   53,   54,   55,   56,   57,   58,   59,   60,
   61,    0,   51,    0,    0,    0,    0,   68,    0,    0,
    0,   52,   53,   54,   55,   56,   57,   58,    0,   60,
    0,    0,   51,    0,    0,    0,    0,   68,    0,    0,
    0,   52,   53,   54,   55,   56,   57,    0,    0,    0,
    0,    3,    4,    5,    6,    7,    0,   68,    0,    0,
    8,    0,    9,    0,   10,   11,   12,   13,   99,    4,
  100,  101,    7,   38,   39,   40,   41,    8,    0,    9,
   45,   10,   11,   12,   13,    0,    0,    0,    0,    0,
    0,    0,   88,    0,   90,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   96,    0,   98,
  102,  105,  106,  107,  108,  109,  110,  111,  112,  113,
  114,  115,  116,  117,  118,  119,  120,  121,  122,  123,
    0,    0,  102,  102,  130,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  147,    0,    0,  150,    0,    0,    0,    0,    0,  152,
  153,  154,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  102,    0,  161,
};
short yycheck[] = {                                      10,
   36,   37,   10,  259,   40,   10,  262,   36,   37,   40,
   10,   40,   10,  259,  286,  287,  262,   10,  265,   40,
  259,   41,   58,  262,   44,   36,   37,   44,   64,   40,
   41,   42,   43,   44,   45,   64,   47,   10,  259,  286,
  287,  262,   41,  286,  287,   44,   41,   58,   59,   44,
   40,   59,   63,   64,   59,   91,   40,  259,   94,   59,
  262,   59,   91,   36,   37,   94,   59,   40,   41,   42,
   43,   44,   45,   93,   47,   10,   93,  262,   41,  262,
   91,   44,   93,   94,  259,   58,   59,  262,   41,   41,
   63,   64,   44,   41,   93,  265,   44,  269,   93,  265,
   10,   36,   37,   73,   74,   40,   41,   42,   43,   44,
   45,  271,   47,   10,  125,  126,   41,  125,   91,   44,
   93,   94,   93,   58,   59,  125,   41,  125,   63,   64,
   93,   41,  125,   93,   44,   41,   10,  262,   44,   41,
   41,   93,   44,   44,   41,   42,   43,   44,   45,   59,
   47,   41,  125,  126,   44,  265,   91,   41,   93,   94,
   44,   58,   59,   10,   10,   93,   63,   41,   42,   43,
   44,   45,   41,   47,   10,   44,  286,  287,   41,   41,
   44,   44,   44,   93,   58,   59,  265,   93,   44,   63,
  125,  126,   93,  132,   41,   41,   93,   44,   44,  156,
   -1,   -1,   -1,   93,   -1,   41,   42,   43,   44,   45,
   -1,   47,   59,   59,   -1,  125,   -1,   63,   -1,   93,
   -1,   -1,   58,   59,   -1,   -1,   -1,   63,  125,  126,
   -1,  267,   -1,   -1,   -1,   -1,   -1,   -1,  267,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   93,   93,   -1,   -1,
   -1,  125,  126,  264,  265,  266,  267,   93,   -1,   -1,
  271,   -1,   -1,   -1,   -1,  276,  277,  278,  279,  280,
  281,  282,  283,  284,  285,   -1,   -1,   -1,  125,  125,
   -1,  292,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  125,
  126,  264,  265,  266,  267,   -1,   -1,   -1,  271,   -1,
   -1,   -1,   -1,  276,  277,  278,  279,  280,  281,  282,
  283,  284,  285,   -1,   -1,   -1,   -1,   -1,   -1,  292,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  264,
  265,  266,  267,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  276,  277,  278,  279,  280,  281,  282,  283,  284,
  285,   -1,   -1,   -1,   -1,  265,   -1,  292,   -1,   -1,
   -1,  271,   -1,   -1,   -1,   -1,   -1,  264,  265,  266,
   -1,   -1,   -1,   -1,  271,   -1,   -1,   -1,   -1,  276,
  277,  278,  279,  280,  281,  282,  283,  284,  285,   -1,
  264,  265,  266,   -1,   -1,  292,   -1,  271,   -1,   -1,
   -1,   -1,  276,  277,  278,  279,  280,  281,  282,  283,
  284,  285,   -1,   -1,   -1,   -1,   -1,   -1,  292,  265,
   10,   -1,   -1,   -1,  271,  271,   -1,   -1,  264,  265,
  266,   -1,   -1,   -1,   -1,  271,   -1,   -1,   -1,   -1,
  276,  277,  278,  279,  280,  281,  282,  283,  284,  285,
   -1,   41,   42,   43,   44,   45,  292,   47,   10,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   36,   37,   58,   59,
   40,   -1,   42,   63,   -1,   -1,   -1,   47,   -1,   -1,
   -1,   10,   -1,   -1,   -1,   -1,   -1,   -1,   58,   41,
   42,   43,   44,   45,   64,   47,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   93,   -1,   -1,   -1,   59,   10,   -1,
   -1,   63,   41,   42,   43,   44,   45,   10,   47,   -1,
   -1,   91,   -1,   -1,   94,   -1,   -1,   -1,   -1,   -1,
   59,   -1,   -1,   -1,   63,  125,  126,   -1,   -1,   41,
   -1,   93,   44,   -1,   -1,   10,   -1,   -1,   41,   42,
   43,   44,   45,   -1,   47,   -1,   -1,   59,   -1,   -1,
   -1,   63,   -1,   -1,   93,   -1,   59,   -1,   10,   -1,
   63,   -1,   -1,  125,  126,   -1,   41,   -1,   43,   44,
   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   93,   -1,   -1,   59,   10,  125,  126,   63,   41,
   93,   43,   44,   45,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   36,   37,   59,   -1,   40,
   -1,   63,   -1,  125,  126,   -1,   41,   -1,   93,   44,
   -1,   -1,  125,  126,   -1,   13,   -1,   58,   -1,   -1,
   18,   -1,   20,   64,   59,   -1,   -1,   -1,   63,   -1,
   -1,   93,   -1,   -1,   32,   -1,   34,   -1,   36,   -1,
  125,  126,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   91,   49,   -1,   94,  264,  265,  266,   -1,   93,   -1,
   -1,  271,   -1,  125,  126,   -1,  276,  277,  278,  279,
  280,  281,  282,  283,  284,  285,   -1,  267,   -1,   -1,
   -1,   -1,  292,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  125,  126,  264,  265,  266,   93,   94,   -1,   -1,  271,
   -1,   -1,  292,   -1,  276,  277,  278,  279,  280,  281,
  282,  283,  284,  285,   -1,  264,  265,  266,   -1,   -1,
  292,   -1,  271,   -1,   -1,   10,   -1,  276,  277,  278,
  279,  280,  281,  282,  283,  284,  285,   -1,  136,   -1,
   -1,   -1,  264,  265,  266,   -1,   -1,   -1,   -1,  271,
  148,  264,  265,  266,   -1,   -1,   41,   -1,  271,   44,
   -1,   -1,   -1,  276,  277,  278,  279,  280,  281,  282,
  283,  284,  285,   -1,   59,   -1,   -1,   -1,   63,  264,
  265,  266,   -1,   -1,   -1,   -1,  271,   -1,   -1,   -1,
   -1,  276,  277,  278,  279,  280,  281,  282,  283,  284,
  285,   -1,  264,  265,  266,   -1,   -1,   -1,   93,  271,
   -1,   10,   -1,   -1,  276,  277,  278,  279,  280,  281,
  282,  283,  284,  285,   -1,   -1,  267,   -1,   -1,  264,
  265,  266,   -1,   -1,   10,   -1,  271,   -1,   -1,   -1,
  125,  126,   41,   -1,   -1,   44,   -1,  282,  283,  284,
  285,  292,   -1,   -1,   -1,   -1,   -1,   10,   -1,   -1,
   59,   -1,   -1,   -1,   63,   41,   -1,   -1,   44,   -1,
   36,   37,   -1,   -1,   40,   -1,   42,   43,   -1,   45,
   10,   47,   -1,   59,   -1,   -1,   -1,   63,   41,   -1,
   -1,   44,   58,   -1,   93,   -1,   -1,   -1,   64,   -1,
   -1,   -1,   -1,   -1,   10,   -1,   59,   -1,   -1,   -1,
   63,   41,   -1,   -1,   44,   -1,   -1,   93,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   91,  125,  126,   94,   59,
   -1,   -1,   -1,   63,   -1,   41,   10,   -1,   44,   -1,
   93,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  125,
  126,   -1,   -1,   59,   10,   -1,   -1,   63,   -1,   33,
   -1,   -1,   -1,   93,   -1,   -1,   40,   -1,   -1,   43,
   -1,   45,  125,  126,   -1,   -1,   -1,   10,   -1,  264,
  265,  266,   -1,   -1,   -1,   41,  271,   93,   44,   63,
   -1,   -1,   -1,   -1,   -1,  125,  126,  282,  283,  284,
  285,   -1,   -1,   59,   10,   -1,   -1,   63,   41,   -1,
   -1,   44,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  125,
  126,   -1,   -1,   -1,   -1,   -1,   59,   10,   -1,   -1,
   63,   -1,   -1,   -1,   -1,   41,   -1,   93,   44,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  123,
   -1,   -1,  126,   59,   -1,   -1,   -1,   63,   41,   -1,
   93,   44,   -1,   -1,   -1,  264,  265,  266,   -1,  125,
  126,   -1,  271,   -1,   -1,   -1,   59,   -1,   -1,   -1,
   63,   -1,   -1,  282,  283,  284,  285,   93,  264,  265,
  266,   10,  125,  126,   -1,  271,   -1,   -1,   -1,   -1,
   -1,  267,   -1,   -1,   -1,   -1,  282,  283,  284,  285,
   93,  264,  265,  266,   -1,   -1,   -1,   -1,  271,  125,
  126,   -1,   41,   -1,   -1,   44,  292,   -1,   -1,  282,
  283,  284,  285,   -1,  264,  265,  266,   -1,   -1,   -1,
   59,  271,  125,  126,   63,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  282,  283,  284,  285,   -1,   -1,  264,  265,
  266,   -1,   -1,   -1,   -1,  271,   -1,   -1,   -1,   -1,
   -1,   10,   -1,   -1,   93,   -1,  282,  283,  284,  285,
   -1,   -1,  256,  257,   -1,  259,  260,  261,  262,  263,
   -1,   10,   -1,   -1,  268,   -1,  270,   -1,  272,  273,
  274,  275,   41,   -1,   -1,   44,  125,  126,  264,  265,
  266,   -1,   -1,   -1,   10,  271,   -1,   -1,   -1,   -1,
   59,   -1,   41,   -1,   63,   44,  282,  283,  284,  285,
   -1,  264,  265,  266,   -1,   -1,   -1,   -1,  271,   -1,
   59,   -1,   -1,   -1,   63,   41,   -1,   -1,   44,  282,
  283,  284,  285,   -1,   93,   -1,   -1,   -1,  264,  265,
  266,   -1,   -1,   59,   -1,  271,   -1,   63,   -1,   -1,
   -1,   -1,   -1,   -1,   93,   -1,   -1,  283,   -1,  285,
   -1,  264,  265,  266,   -1,   -1,  125,   -1,  271,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   93,   -1,   -1,
  283,   -1,  285,   36,   37,   -1,  125,   40,   41,   42,
   43,   44,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   58,   -1,   -1,   -1,  125,
   63,   64,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  264,  265,  266,   -1,   -1,
   -1,   -1,  271,   -1,   -1,   -1,   -1,   -1,   91,   -1,
   93,   94,   -1,   36,   37,   -1,   -1,   40,   41,   42,
   43,   44,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   58,   -1,   -1,   -1,   -1,
   63,   64,   -1,  126,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   36,   37,   -1,   -1,   40,   41,   42,   43,   44,
   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,   91,   -1,
   93,   94,   -1,   58,   -1,  264,  265,  266,   63,   64,
   -1,   -1,  271,   -1,   -1,   -1,   -1,   -1,   36,   37,
   -1,   -1,   40,   -1,   42,   43,  265,   45,   -1,   47,
   -1,   -1,  271,  126,   -1,   -1,   91,   -1,   93,   94,
   58,   -1,   -1,   -1,   -1,   63,   64,   36,   37,  265,
   -1,   40,   41,   42,   43,  271,   45,   -1,   47,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   58,
   -1,  126,   -1,   91,   63,   64,   94,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   36,   37,
   -1,   -1,   40,   41,   42,   43,   -1,   45,   -1,   47,
   -1,   -1,   91,   -1,   -1,   94,   -1,   -1,  126,   -1,
   58,  264,   -1,  266,  267,   63,   64,   -1,   -1,   -1,
   -1,   -1,   -1,  276,  277,  278,  279,  280,  281,  282,
  283,  284,  285,   -1,   -1,   -1,   -1,  126,   -1,  292,
   -1,   -1,   -1,   91,   -1,   -1,   94,   -1,   36,   37,
   -1,   -1,   40,   41,   42,   43,   -1,   45,   -1,   47,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   58,  264,   -1,  266,  267,   63,   64,   -1,  126,   -1,
   -1,   -1,   -1,  276,  277,  278,  279,  280,  281,  282,
  283,  284,  285,   -1,   -1,   -1,   -1,   -1,   -1,  292,
   -1,   -1,   -1,   91,   -1,   -1,   94,   -1,   -1,  264,
   -1,  266,  267,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  276,  277,  278,  279,  280,  281,  282,  283,  284,
  285,   -1,   -1,   -1,   -1,   -1,   -1,  292,  126,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  264,  265,  266,  267,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  276,  277,
  278,  279,  280,  281,  282,  283,  284,  285,   -1,   -1,
   -1,   -1,   -1,   -1,  292,  264,   -1,  266,  267,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  276,  277,  278,
  279,  280,  281,  282,  283,  284,  285,   -1,   -1,   -1,
   -1,   -1,   -1,  292,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  264,   -1,  266,  267,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  276,  277,
  278,  279,  280,  281,  282,  283,  284,  285,   -1,   -1,
   -1,   -1,   -1,   -1,  292,   36,   37,   -1,   -1,   40,
   -1,   42,   43,   -1,   45,   -1,   47,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   58,   -1,   -1,
   -1,   -1,   63,   64,   -1,   -1,  264,   -1,  266,  267,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  276,  277,
  278,  279,  280,  281,  282,  283,  284,  285,   -1,   -1,
   91,   36,   37,   94,  292,   40,   -1,   42,   43,   -1,
   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   36,   37,   58,   -1,   40,   -1,   42,   43,   64,
   45,   -1,   47,   -1,   -1,  126,   -1,   -1,   -1,   -1,
   -1,   36,   37,   58,   -1,   40,   -1,   42,   43,   64,
   45,   -1,   47,   -1,   -1,   -1,   91,   -1,   -1,   94,
   -1,   36,   37,   58,   -1,   40,   -1,   42,   43,   64,
   45,   -1,   47,   -1,   -1,   -1,   91,   -1,   -1,   94,
   -1,   36,   37,   58,   -1,   40,   -1,   42,   43,   64,
   45,  126,   47,   -1,   -1,   -1,   91,   -1,   -1,   94,
   -1,   -1,   -1,   58,   -1,   33,   -1,   -1,   -1,   64,
   -1,  126,   40,   -1,   -1,   43,   91,   45,   -1,   94,
   -1,   -1,   33,   -1,   -1,   -1,   -1,   -1,   -1,   40,
   -1,   -1,   43,   -1,   45,   63,   91,   -1,   -1,   94,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   63,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  264,   -1,  266,  267,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  276,  277,  278,  279,  280,
  281,  282,  283,  284,  285,  123,   -1,   -1,  126,   -1,
   -1,  292,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  123,   -1,   -1,  126,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  264,
   -1,  266,  267,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  276,  277,  278,  279,  280,  281,  282,  283,  284,
  285,   -1,  267,   -1,   -1,   -1,   -1,  292,   -1,   -1,
   -1,  276,  277,  278,  279,  280,  281,  282,  283,  284,
  285,   -1,  267,   -1,   -1,   -1,   -1,  292,   -1,   -1,
   -1,  276,  277,  278,  279,  280,  281,  282,  283,  284,
  285,   -1,  267,   -1,   -1,   -1,   -1,  292,   -1,   -1,
   -1,  276,  277,  278,  279,  280,  281,  282,   -1,  284,
   -1,   -1,  267,   -1,   -1,   -1,   -1,  292,   -1,   -1,
   -1,  276,  277,  278,  279,  280,  281,   -1,   -1,   -1,
   -1,  259,  260,  261,  262,  263,   -1,  292,   -1,   -1,
  268,   -1,  270,   -1,  272,  273,  274,  275,  259,  260,
  261,  262,  263,   14,   15,   16,   17,  268,   -1,  270,
   21,  272,  273,  274,  275,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   33,   -1,   35,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   48,   -1,   50,
   51,   52,   53,   54,   55,   56,   57,   58,   59,   60,
   61,   62,   63,   64,   65,   66,   67,   68,   69,   70,
   -1,   -1,   73,   74,   75,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  131,   -1,   -1,  134,   -1,   -1,   -1,   -1,   -1,  140,
  141,  142,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  156,   -1,  158,
};
#define YYFINAL 22
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 294
#if YYDEBUG
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,"'\\n'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,"'!'",0,0,"'$'","'%'",0,0,"'('","')'","'*'","'+'","','","'-'",0,"'/'",0,0,0,
0,0,0,0,0,0,0,"':'","';'",0,0,0,"'?'","'@'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,"'['",0,"']'","'^'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,"'{'",0,"'}'","'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"END_OF_INPUT","ERROR",
"STR_CONST","NUM_CONST","NULL_CONST","SYMBOL","FUNCTION","LEFT_ASSIGN",
"EQ_ASSIGN","RIGHT_ASSIGN","LBB","FOR","IN","IF","ELSE","WHILE","NEXT","BREAK",
"REPEAT","GT","GE","LT","LE","EQ","NE","AND","OR","AND2","OR2","NS_GET",
"NS_GET_INT","LOW","TILDE","UNOT","NOT","SPECIAL","UMINUS","UPLUS",
};
char *yyrule[] = {
"$accept : prog",
"prog : END_OF_INPUT",
"prog : '\\n'",
"prog : expr_or_assign '\\n'",
"prog : expr_or_assign ';'",
"prog : error",
"expr_or_assign : expr",
"expr_or_assign : equal_assign",
"equal_assign : expr EQ_ASSIGN expr_or_assign",
"expr : NUM_CONST",
"expr : STR_CONST",
"expr : NULL_CONST",
"expr : SYMBOL",
"expr : '{' exprlist '}'",
"expr : '(' expr_or_assign ')'",
"expr : '-' expr",
"expr : '+' expr",
"expr : '!' expr",
"expr : '~' expr",
"expr : '?' expr",
"expr : expr ':' expr",
"expr : expr '+' expr",
"expr : expr '-' expr",
"expr : expr '*' expr",
"expr : expr '/' expr",
"expr : expr '^' expr",
"expr : expr SPECIAL expr",
"expr : expr '%' expr",
"expr : expr '~' expr",
"expr : expr '?' expr",
"expr : expr LT expr",
"expr : expr LE expr",
"expr : expr EQ expr",
"expr : expr NE expr",
"expr : expr GE expr",
"expr : expr GT expr",
"expr : expr AND expr",
"expr : expr OR expr",
"expr : expr AND2 expr",
"expr : expr OR2 expr",
"expr : expr LEFT_ASSIGN expr",
"expr : expr RIGHT_ASSIGN expr",
"expr : FUNCTION '(' formlist ')' cr expr_or_assign",
"expr : expr '(' sublist ')'",
"expr : IF ifcond expr_or_assign",
"expr : IF ifcond expr_or_assign ELSE expr_or_assign",
"expr : FOR forcond expr_or_assign",
"expr : WHILE cond expr_or_assign",
"expr : REPEAT expr_or_assign",
"expr : expr LBB sublist ']' ']'",
"expr : expr '[' sublist ']'",
"expr : SYMBOL NS_GET SYMBOL",
"expr : SYMBOL NS_GET STR_CONST",
"expr : STR_CONST NS_GET SYMBOL",
"expr : STR_CONST NS_GET STR_CONST",
"expr : SYMBOL NS_GET_INT SYMBOL",
"expr : SYMBOL NS_GET_INT STR_CONST",
"expr : STR_CONST NS_GET_INT SYMBOL",
"expr : STR_CONST NS_GET_INT STR_CONST",
"expr : expr '$' SYMBOL",
"expr : expr '$' STR_CONST",
"expr : expr '@' SYMBOL",
"expr : expr '@' STR_CONST",
"expr : NEXT",
"expr : BREAK",
"cond : '(' expr ')'",
"ifcond : '(' expr ')'",
"forcond : '(' SYMBOL IN expr ')'",
"exprlist :",
"exprlist : expr_or_assign",
"exprlist : exprlist ';' expr_or_assign",
"exprlist : exprlist ';'",
"exprlist : exprlist '\\n' expr_or_assign",
"exprlist : exprlist '\\n'",
"sublist : sub",
"sublist : sublist cr ',' sub",
"sub :",
"sub : expr",
"sub : SYMBOL EQ_ASSIGN",
"sub : SYMBOL EQ_ASSIGN expr",
"sub : STR_CONST EQ_ASSIGN",
"sub : STR_CONST EQ_ASSIGN expr",
"sub : NULL_CONST EQ_ASSIGN",
"sub : NULL_CONST EQ_ASSIGN expr",
"formlist :",
"formlist : SYMBOL",
"formlist : SYMBOL EQ_ASSIGN expr",
"formlist : formlist ',' SYMBOL",
"formlist : formlist ',' SYMBOL EQ_ASSIGN expr",
"cr :",
};
#endif
#ifndef YYSTYPE
typedef int YYSTYPE;
#endif
#if YYDEBUG
#include <stdio.h>
#endif

/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH  500
#endif
#endif

#define YYINITSTACKSIZE 500

int      yydebug;
int      yynerrs;
int      yyerrflag;
int      yychar;
short   *yyssp;
YYSTYPE *yyvsp;
YYSTYPE  yyval;
YYSTYPE  yylval;

/* variables for the parser stack */
static short   *yyss;
static short   *yysslim;
static YYSTYPE *yyvs;
static int      yystacksize;
#line 359 "../gram.y"


/*----------------------------------------------------------------------------*/

static int (*ptr_getc)(void);

/* Private pushback, since file ungetc only guarantees one byte.
   We need up to one MBCS-worth */

#define PUSHBACK_BUFSIZE 16
static int pushback[PUSHBACK_BUFSIZE];
static unsigned int npush = 0;

static int prevpos = 0;
static int prevlines[PUSHBACK_BUFSIZE];
static int prevcols[PUSHBACK_BUFSIZE];
static int prevbytes[PUSHBACK_BUFSIZE];

static int xxgetc(void)
{
    int c;

    if(npush) c = pushback[--npush]; else  c = ptr_getc();

    prevpos = (prevpos + 1) % PUSHBACK_BUFSIZE;
    prevcols[prevpos] = xxcolno;
    prevbytes[prevpos] = xxbyteno;
    prevlines[prevpos] = xxlineno;    
    
    if (c == EOF) {
	EndOfFile = 1;
	return R_EOF;
    }
    R_ParseContextLast = (R_ParseContextLast + 1) % PARSE_CONTEXT_SIZE;
    R_ParseContext[R_ParseContextLast] = c;

    if (c == '\n') {
	xxlineno += 1;
	xxcolno = 0;
    	xxbyteno = 0;
    } else {
        xxcolno++;
    	xxbyteno++;
    }
    /* only advance column for 1st byte in UTF-8 */
    if (0x80 <= (unsigned char)c && (unsigned char)c <= 0xBF && known_to_be_utf8) 
    	xxcolno--;

    if (c == '\t') xxcolno = ((xxcolno + 7) & ~7);
    
    R_ParseContextLine = xxlineno;    

    if ( KeepSource && GenerateCode && FunctionLevel > 0 ) {
	if(SourcePtr <  FunctionSource + MAXFUNSIZE)
	    *SourcePtr++ = c;
	else  error(_("function is too long to keep source (at line %d)"), xxlineno);
    }
    xxcharcount++;
    return c;
}

static int xxungetc(int c)
{
    /* this assumes that c was the result of xxgetc; if not, some edits will be needed */
    xxlineno = prevlines[prevpos];
    xxbyteno = prevbytes[prevpos];
    xxcolno  = prevcols[prevpos];
    prevpos = (prevpos + PUSHBACK_BUFSIZE - 1) % PUSHBACK_BUFSIZE;

    R_ParseContextLine = xxlineno;
    if ( KeepSource && GenerateCode && FunctionLevel > 0 )
	SourcePtr--;
    xxcharcount--;
    R_ParseContext[R_ParseContextLast] = '\0';
    /* precaution as to how % is implemented for < 0 numbers */
    R_ParseContextLast = (R_ParseContextLast + PARSE_CONTEXT_SIZE -1) % PARSE_CONTEXT_SIZE;
    if(npush >= PUSHBACK_BUFSIZE) return EOF;
    pushback[npush++] = c;
    return c;
}

static SEXP makeSrcref(YYLTYPE *lloc, SEXP srcfile)
{
    SEXP val;

    PROTECT(val = allocVector(INTSXP, 6));
    INTEGER(val)[0] = lloc->first_line;
    INTEGER(val)[1] = lloc->first_byte;
    INTEGER(val)[2] = lloc->last_line;
    INTEGER(val)[3] = lloc->last_byte;
    INTEGER(val)[4] = lloc->first_column;
    INTEGER(val)[5] = lloc->last_column;
    setAttrib(val, R_SrcfileSymbol, srcfile);
    setAttrib(val, R_ClassSymbol, mkString("srcref"));
    UNPROTECT(1);
    return val;
}

static SEXP attachSrcrefs(SEXP val, SEXP srcfile)
{
    SEXP t, srval;
    int n;

    PROTECT(val);
    t = CDR(SrcRefs);
    srval = allocVector(VECSXP, length(t));
    for (n = 0 ; n < LENGTH(srval) ; n++, t = CDR(t))
	SET_VECTOR_ELT(srval, n, CAR(t));
    setAttrib(val, R_SrcrefSymbol, srval);
    setAttrib(val, R_SrcfileSymbol, srcfile);
    UNPROTECT(1);
    SrcRefs = NULL;
    return val;
}

static int xxvalue(SEXP v, int k, YYLTYPE *lloc)
{
    if (k > 2) {
	if (SrcFile)
	    REPROTECT(SrcRefs = GrowList(SrcRefs, makeSrcref(lloc, SrcFile)), srindex);
	UNPROTECT_PTR(v);
    }
    R_CurrentExpr = v;
    return k;
}

static SEXP xxnullformal()
{
    SEXP ans;
    PROTECT(ans = R_NilValue);
    return ans;
}

static SEXP xxfirstformal0(SEXP sym)
{
    SEXP ans;
    UNPROTECT_PTR(sym);
    if (GenerateCode)
	PROTECT(ans = FirstArg(R_MissingArg, sym));
    else
	PROTECT(ans = R_NilValue);
    return ans;
}

static SEXP xxfirstformal1(SEXP sym, SEXP expr)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = FirstArg(expr, sym));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(expr);
    UNPROTECT_PTR(sym);
    return ans;
}

static SEXP xxaddformal0(SEXP formlist, SEXP sym, YYLTYPE *lloc)
{
    SEXP ans;
    if (GenerateCode) {
	CheckFormalArgs(formlist, sym, lloc);
	PROTECT(ans = NextArg(formlist, R_MissingArg, sym));
    }
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(sym);
    UNPROTECT_PTR(formlist);
    return ans;
}

static SEXP xxaddformal1(SEXP formlist, SEXP sym, SEXP expr, YYLTYPE *lloc)
{
    SEXP ans;
    if (GenerateCode) {
	CheckFormalArgs(formlist, sym, lloc);
	PROTECT(ans = NextArg(formlist, expr, sym));
    }
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(expr);
    UNPROTECT_PTR(sym);
    UNPROTECT_PTR(formlist);
    return ans;
}

static SEXP xxexprlist0(void)
{
    SEXP ans;
    if (GenerateCode) {
	PROTECT(ans = NewList());
	if (SrcFile) {
	    setAttrib(ans, R_SrcrefSymbol, SrcRefs);
	    REPROTECT(SrcRefs = NewList(), srindex);
	}
    }
    else
	PROTECT(ans = R_NilValue);
    return ans;
}

static SEXP xxexprlist1(SEXP expr, YYLTYPE *lloc)
{
    SEXP ans,tmp;
    if (GenerateCode) {
	PROTECT(tmp = NewList());
	if (SrcFile) {
	    setAttrib(tmp, R_SrcrefSymbol, SrcRefs);
	    REPROTECT(SrcRefs = NewList(), srindex);
	    REPROTECT(SrcRefs = GrowList(SrcRefs, makeSrcref(lloc, SrcFile)), srindex);
	}
	PROTECT(ans = GrowList(tmp, expr));
	UNPROTECT_PTR(tmp);
    }
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(expr);
    return ans;
}

static SEXP xxexprlist2(SEXP exprlist, SEXP expr, YYLTYPE *lloc)
{
    SEXP ans;
    if (GenerateCode) {
	if (SrcFile)
	    REPROTECT(SrcRefs = GrowList(SrcRefs, makeSrcref(lloc, SrcFile)), srindex);
	PROTECT(ans = GrowList(exprlist, expr));
    }
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(expr);
    UNPROTECT_PTR(exprlist);
    return ans;
}

static SEXP xxsub0(void)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = lang2(R_MissingArg,R_NilValue));
    else
	PROTECT(ans = R_NilValue);
    return ans;
}

static SEXP xxsub1(SEXP expr, YYLTYPE *lloc)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = TagArg(expr, R_NilValue, lloc));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(expr);
    return ans;
}

static SEXP xxsymsub0(SEXP sym, YYLTYPE *lloc)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = TagArg(R_MissingArg, sym, lloc));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(sym);
    return ans;
}

static SEXP xxsymsub1(SEXP sym, SEXP expr, YYLTYPE *lloc)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = TagArg(expr, sym, lloc));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(expr);
    UNPROTECT_PTR(sym);
    return ans;
}

static SEXP xxnullsub0(YYLTYPE *lloc)
{
    SEXP ans;
    UNPROTECT_PTR(R_NilValue);
    if (GenerateCode)
	PROTECT(ans = TagArg(R_MissingArg, install("NULL"), lloc));
    else
	PROTECT(ans = R_NilValue);
    return ans;
}

static SEXP xxnullsub1(SEXP expr, YYLTYPE *lloc)
{
    SEXP ans = install("NULL");
    UNPROTECT_PTR(R_NilValue);
    if (GenerateCode)
	PROTECT(ans = TagArg(expr, ans, lloc));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(expr);
    return ans;
}


static SEXP xxsublist1(SEXP sub)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = FirstArg(CAR(sub),CADR(sub)));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(sub);
    return ans;
}

static SEXP xxsublist2(SEXP sublist, SEXP sub)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = NextArg(sublist, CAR(sub), CADR(sub)));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(sub);
    UNPROTECT_PTR(sublist);
    return ans;
}

static SEXP xxcond(SEXP expr)
{
    EatLines = 1;
    return expr;
}

static SEXP xxifcond(SEXP expr)
{
    EatLines = 1;
    return expr;
}

static SEXP xxif(SEXP ifsym, SEXP cond, SEXP expr)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = lang3(ifsym, cond, expr));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(expr);
    UNPROTECT_PTR(cond);
    return ans;
}

static SEXP xxifelse(SEXP ifsym, SEXP cond, SEXP ifexpr, SEXP elseexpr)
{
    SEXP ans;
    if( GenerateCode)
	PROTECT(ans = lang4(ifsym, cond, ifexpr, elseexpr));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(elseexpr);
    UNPROTECT_PTR(ifexpr);
    UNPROTECT_PTR(cond);
    return ans;
}

static SEXP xxforcond(SEXP sym, SEXP expr)
{
    SEXP ans;
    EatLines = 1;
    if (GenerateCode)
	PROTECT(ans = LCONS(sym, expr));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(expr);
    UNPROTECT_PTR(sym);
    return ans;
}

static SEXP xxfor(SEXP forsym, SEXP forcond, SEXP body)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = lang4(forsym, CAR(forcond), CDR(forcond), body));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(body);
    UNPROTECT_PTR(forcond);
    return ans;
}

static SEXP xxwhile(SEXP whilesym, SEXP cond, SEXP body)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = lang3(whilesym, cond, body));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(body);
    UNPROTECT_PTR(cond);
    return ans;
}

static SEXP xxrepeat(SEXP repeatsym, SEXP body)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = lang2(repeatsym, body));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(body);
    return ans;
}

static SEXP xxnxtbrk(SEXP keyword)
{
    if (GenerateCode)
	PROTECT(keyword = lang1(keyword));
    else
	PROTECT(keyword = R_NilValue);
    return keyword;
}

static SEXP xxfuncall(SEXP expr, SEXP args)
{
    SEXP ans, sav_expr = expr;
    if(GenerateCode) {
	if (isString(expr))
	    expr = install(CHAR(STRING_ELT(expr, 0)));
	PROTECT(expr);
	if (length(CDR(args)) == 1 && CADR(args) == R_MissingArg && TAG(CDR(args)) == R_NilValue )
	    ans = lang1(expr);
	else
	    ans = LCONS(expr, CDR(args));
	UNPROTECT(1);
	PROTECT(ans);
    }
    else {
	PROTECT(ans = R_NilValue);
    }
    UNPROTECT_PTR(args);
    UNPROTECT_PTR(sav_expr);
    return ans;
}

static SEXP mkString2(const char *s, int len)
{
    SEXP t;
    cetype_t enc = CE_NATIVE;

    if(known_to_be_latin1) enc= CE_LATIN1;
    else if(known_to_be_utf8) enc = CE_UTF8;

    PROTECT(t = allocVector(STRSXP, 1));
    SET_STRING_ELT(t, 0, mkCharLenCE(s, len, enc));
    UNPROTECT(1);
    return t;
}

static SEXP xxdefun(SEXP fname, SEXP formals, SEXP body)
{

    SEXP ans;
    SEXP source;

    if (GenerateCode) {
	if (!KeepSource)
	    PROTECT(source = R_NilValue);
	else {
	    unsigned char *p, *p0, *end;
	    int lines = 0, nc;

	    /*  If the function ends with an endline comment,  e.g.

		function()
		    print("Hey") # This comment

		we need some special handling to keep it from getting
		chopped off. Normally, we will have read one token too
		far, which is what xxcharcount and xxcharsave keeps
		track of.

	    */
	    end = SourcePtr - (xxcharcount - xxcharsave);
	    /* FIXME: this should be whitespace */
	    for (p = end ; p < SourcePtr && (*p == ' ' || *p == '\t') ; p++)
		;
	    if (*p == '#') {
		while (p < SourcePtr && *p != '\n')
		    p++;
		end = p;
	    }

	    for (p = FunctionStart[FunctionLevel]; p < end ; p++)
		if (*p == '\n') lines++;
	    if ( *(end - 1) != '\n' ) lines++;
	    PROTECT(source = allocVector(STRSXP, lines));
	    p0 = FunctionStart[FunctionLevel];
	    lines = 0;
	    for (p = FunctionStart[FunctionLevel]; p < end ; p++)
		if (*p == '\n' || p == end - 1) {
		    cetype_t enc = CE_NATIVE;
		    nc = p - p0;
		    if (*p != '\n') nc++;
		    if(known_to_be_latin1) enc = CE_LATIN1;
		    else if(known_to_be_utf8) enc = CE_UTF8;
		    SET_STRING_ELT(source, lines++,
				   mkCharLenCE((char *)p0, nc, enc));
		    p0 = p + 1;
		}
	    /* PrintValue(source); */
	}
	PROTECT(ans = lang4(fname, CDR(formals), body, source));
	UNPROTECT_PTR(source);
    }
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(body);
    UNPROTECT_PTR(formals);
    FunctionLevel--;
    return ans;
}

static SEXP xxunary(SEXP op, SEXP arg)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = lang2(op, arg));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(arg);
    return ans;
}

static SEXP xxbinary(SEXP n1, SEXP n2, SEXP n3)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = lang3(n1, n2, n3));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(n2);
    UNPROTECT_PTR(n3);
    return ans;
}

static SEXP xxparen(SEXP n1, SEXP n2)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = lang2(n1, n2));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(n2);
    return ans;
}


/* This should probably use CONS rather than LCONS, but
   it shouldn't matter and we would rather not meddle
   See PR#7055 */

static SEXP xxsubscript(SEXP a1, SEXP a2, SEXP a3)
{
    SEXP ans;
    if (GenerateCode)
	PROTECT(ans = LCONS(a2, CONS(a1, CDR(a3))));
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(a3);
    UNPROTECT_PTR(a1);
    return ans;
}

static SEXP xxexprlist(SEXP a1, YYLTYPE *lloc, SEXP a2)
{
    SEXP ans;
    SEXP prevSrcrefs;

    EatLines = 0;
    if (GenerateCode) {
	SET_TYPEOF(a2, LANGSXP);
	SETCAR(a2, a1);
	if (SrcFile) {
	    PROTECT(prevSrcrefs = getAttrib(a2, R_SrcrefSymbol));
	    REPROTECT(SrcRefs = Insert(SrcRefs, makeSrcref(lloc, SrcFile)), srindex);
	    PROTECT(ans = attachSrcrefs(a2, SrcFile));
	    REPROTECT(SrcRefs = prevSrcrefs, srindex);
	    /* SrcRefs got NAMED by being an attribute... */
	    SET_NAMED(SrcRefs, 0);
	    UNPROTECT_PTR(prevSrcrefs);
	}
	else
	    PROTECT(ans = a2);
    }
    else
	PROTECT(ans = R_NilValue);
    UNPROTECT_PTR(a2);
    return ans;
}

/*--------------------------------------------------------------------------*/

static SEXP TagArg(SEXP arg, SEXP tag, YYLTYPE *lloc)
{
    switch (TYPEOF(tag)) {
    case STRSXP:
	tag = install(translateChar(STRING_ELT(tag, 0)));
    case NILSXP:
    case SYMSXP:
	return lang2(arg, tag);
    default:
	error(_("incorrect tag type at line %d"), lloc->first_line); return R_NilValue/* -Wall */;
    }
}


/* Stretchy List Structures : Lists are created and grown using a special */
/* dotted pair.  The CAR of the list points to the last cons-cell in the */
/* list and the CDR points to the first.  The list can be extracted from */
/* the pair by taking its CDR, while the CAR gives fast access to the end */
/* of the list. */


/* Create a stretchy-list dotted pair */

static SEXP NewList(void)
{
    SEXP s = CONS(R_NilValue, R_NilValue);
    SETCAR(s, s);
    return s;
}

/* Add a new element at the end of a stretchy list */

static SEXP GrowList(SEXP l, SEXP s)
{
    SEXP tmp;
    PROTECT(s);
    tmp = CONS(s, R_NilValue);
    UNPROTECT(1);
    SETCDR(CAR(l), tmp);
    SETCAR(l, tmp);
    return l;
}

/* Insert a new element at the head of a stretchy list */

static SEXP Insert(SEXP l, SEXP s)
{
    SEXP tmp;
    PROTECT(s);
    tmp = CONS(s, CDR(l));
    UNPROTECT(1);
    SETCDR(l, tmp);
    return l;
}

static SEXP FirstArg(SEXP s, SEXP tag)
{
    SEXP tmp;
    PROTECT(s);
    PROTECT(tag);
    PROTECT(tmp = NewList());
    tmp = GrowList(tmp, s);
    SET_TAG(CAR(tmp), tag);
    UNPROTECT(3);
    return tmp;
}

static SEXP NextArg(SEXP l, SEXP s, SEXP tag)
{
    PROTECT(tag);
    PROTECT(l);
    l = GrowList(l, s);
    SET_TAG(CAR(l), tag);
    UNPROTECT(2);
    return l;
}



/*--------------------------------------------------------------------------*/

/*
 *  Parsing Entry Points:
 *
 *  The Following entry points provide language parsing facilities.
 *  Note that there are separate entry points for parsing IoBuffers
 *  (i.e. interactve use), files and R character strings.
 *
 *  The entry points provide the same functionality, they just
 *  set things up in slightly different ways.
 *
 *  The following routines parse a single expression:
 *
 *
 *	SEXP R_Parse1File(FILE *fp, int gencode, ParseStatus *status)
 *
 *	SEXP R_Parse1Vector(TextBuffer *text, int gencode, ParseStatus *status)
 *      [Unused]
 *
 *	SEXP R_Parse1Buffer(IoBuffer *buffer, int gencode, ParseStatus *status)
 *
 *
 *  The success of the parse is indicated as folllows:
 *
 *
 *	status = PARSE_NULL       - there was no statement to parse
 *		 PARSE_OK	  - complete statement
 *		 PARSE_INCOMPLETE - incomplete statement
 *		 PARSE_ERROR      - syntax error
 *		 PARSE_EOF	  - end of file
 *
 *
 *  The following routines parse several expressions and return
 *  their values in a single expression vector.
 *
 *	SEXP R_ParseFile(FILE *fp, int n, ParseStatus *status, SEXP srcfile)
 *
 *	SEXP R_ParseVector(SEXP *text, int n, ParseStatus *status, SEXP srcfile)
 *
 *	SEXP R_ParseBuffer(IoBuffer *buffer, int n, ParseStatus *status, SEXP prompt, SEXP srcfile)
 *
 *  Here, status is 1 for a successful parse and 0 if parsing failed
 *  for some reason.
 */

#define CONTEXTSTACK_SIZE 50
static int	SavedToken;
static SEXP	SavedLval;
static char	contextstack[CONTEXTSTACK_SIZE], *contextp;

static void ParseInit(void)
{
    contextp = contextstack;
    *contextp = ' ';
    SavedToken = 0;
    SavedLval = R_NilValue;
    EatLines = 0;
    EndOfFile = 0;
    FunctionLevel=0;
    SourcePtr = FunctionSource;
    xxcharcount = 0;
    KeepSource = *LOGICAL(GetOption(install("keep.source"), R_BaseEnv));
    npush = 0;
}

static void ParseContextInit(void)
{
    R_ParseContextLast = 0;
    R_ParseContext[0] = '\0';
}

static SEXP R_Parse1(ParseStatus *status)
{
    switch(yyparse()) {
    case 0:                     /* End of file */
	*status = PARSE_EOF;
	if (EndOfFile == 2) *status = PARSE_INCOMPLETE;
	break;
    case 1:                     /* Syntax error / incomplete */
	*status = PARSE_ERROR;
	if (EndOfFile) *status = PARSE_INCOMPLETE;
	break;
    case 2:                     /* Empty Line */
	*status = PARSE_NULL;
	break;
    case 3:                     /* Valid expr '\n' terminated */
    case 4:                     /* Valid expr ';' terminated */
	*status = PARSE_OK;
	break;
    }
    return R_CurrentExpr;
}

static FILE *fp_parse;

static int file_getc(void)
{
    return R_fgetc(fp_parse);
}

/* used in main.c and this file */
attribute_hidden
SEXP R_Parse1File(FILE *fp, int gencode, ParseStatus *status)
{
    ParseInit();
    ParseContextInit();
    GenerateCode = gencode;
    fp_parse = fp;
    ptr_getc = file_getc;
    R_Parse1(status);
    return R_CurrentExpr;
}

static IoBuffer *iob;

static int buffer_getc(void)
{
    return R_IoBufferGetc(iob);
}

/* Used only in main.c, rproxy_impl.c */
attribute_hidden
SEXP R_Parse1Buffer(IoBuffer *buffer, int gencode, ParseStatus *status)
{
    xxlineno = 1;
    xxcolno = 0;
    ParseInit();
    ParseContextInit();
    GenerateCode = gencode;
    iob = buffer;
    ptr_getc = buffer_getc;
    R_Parse1(status);
    return R_CurrentExpr;
}

static TextBuffer *txtb;

static int text_getc(void)
{
    return R_TextBufferGetc(txtb);
}

static SEXP R_Parse(int n, ParseStatus *status, SEXP srcfile)
{
    volatile int savestack;
    int i;
    SEXP t, rval;

    ParseContextInit();
    savestack = R_PPStackTop;
    PROTECT(t = NewList());

    xxlineno = 1;
    xxcolno = 0;
    xxbyteno = 0;
    if (!isNull(srcfile)) {
	SrcFile = srcfile;
	PROTECT_WITH_INDEX(SrcRefs = NewList(), &srindex);
    }
    else SrcFile = NULL;

    for(i = 0; ; ) {
	if(n >= 0 && i >= n) break;
	ParseInit();
	rval = R_Parse1(status);
	switch(*status) {
	case PARSE_NULL:
	    break;
	case PARSE_OK:
	    t = GrowList(t, rval);
	    i++;
	    break;
	case PARSE_INCOMPLETE:
	case PARSE_ERROR:
	    R_PPStackTop = savestack;
	    SrcFile = NULL;
	    return R_NilValue;
	    break;
	case PARSE_EOF:
	    goto finish;
	    break;
	}
    }

finish:

    t = CDR(t);
    rval = allocVector(EXPRSXP, length(t));
    for (n = 0 ; n < LENGTH(rval) ; n++, t = CDR(t))
	SET_VECTOR_ELT(rval, n, CAR(t));
    if (SrcFile) {
	rval = attachSrcrefs(rval, SrcFile);
	SrcFile = NULL;
    }
    R_PPStackTop = savestack;
    *status = PARSE_OK;
    return rval;
}

/* used in edit.c */
attribute_hidden
SEXP R_ParseFile(FILE *fp, int n, ParseStatus *status, SEXP srcfile)
{
    GenerateCode = 1;
    fp_parse = fp;
    ptr_getc = file_getc;
    return R_Parse(n, status, srcfile);
}

/* #include <Rconnections.h> */ 
static Rconnection con_parse;

/* need to handle incomplete last line */
static int con_getc(void)
{
    int c;
    static int last=-1000;

    c = Rconn_fgetc(con_parse);
    if (c == EOF && last != '\n') c = '\n';
    return (last = c);
}

/* used in source.c */
attribute_hidden
SEXP R_ParseConn(Rconnection con, int n, ParseStatus *status, SEXP srcfile)
{
    GenerateCode = 1;
    con_parse = con;
    ptr_getc = con_getc;
    return R_Parse(n, status, srcfile);
}

/* This one is public, and used in source.c */
SEXP R_ParseVector(SEXP text, int n, ParseStatus *status, SEXP srcfile)
{
    SEXP rval;
    TextBuffer textb;
    R_TextBufferInit(&textb, text);
    txtb = &textb;
    GenerateCode = 1;
    ptr_getc = text_getc;
    rval = R_Parse(n, status, srcfile);
    R_TextBufferFree(&textb);
    return rval;
}

static const char *Prompt(SEXP prompt, int type)
{
    if(type == 1) {
	if(length(prompt) <= 0) {
	    return CHAR(STRING_ELT(GetOption(install("prompt"),
					     R_BaseEnv), 0));
	}
	else
	    return CHAR(STRING_ELT(prompt, 0));
    }
    else {
	return CHAR(STRING_ELT(GetOption(install("continue"),
					 R_BaseEnv), 0));
    }
}

/* used in source.c */
attribute_hidden
SEXP R_ParseBuffer(IoBuffer *buffer, int n, ParseStatus *status, SEXP prompt, SEXP srcfile)
{
    SEXP rval, t;
    char *bufp, buf[1024];
    int c, i, prompt_type = 1;
    volatile int savestack;

    R_IoBufferWriteReset(buffer);
    buf[0] = '\0';
    bufp = buf;
    savestack = R_PPStackTop;
    PROTECT(t = NewList());

    xxlineno = 1;
    xxcolno = 0;
    xxbyteno = 0;
    GenerateCode = 1;
    iob = buffer;
    ptr_getc = buffer_getc;

    if (!isNull(srcfile)) {
	SrcFile = srcfile;
	PROTECT_WITH_INDEX(SrcRefs = NewList(), &srindex);
    }
    else SrcFile = NULL;

    for(i = 0; ; ) {
	if(n >= 0 && i >= n) break;
	if (!*bufp) {
	    if(R_ReadConsole((char *) Prompt(prompt, prompt_type),
			     (unsigned char *)buf, 1024, 1) == 0)
		goto finish;
	    bufp = buf;
	}
	while ((c = *bufp++)) {
	    R_IoBufferPutc(c, buffer);
	    if (c == ';' || c == '\n') break;
	}

	/* Was a call to R_Parse1Buffer, but we don't want to reset xxlineno and xxcolno */
	ParseInit();
	ParseContextInit();
	R_Parse1(status);
	rval = R_CurrentExpr;

	switch(*status) {
	case PARSE_NULL:
	    break;
	case PARSE_OK:
	    t = GrowList(t, rval);
	    i++;
	    break;
	case PARSE_INCOMPLETE:
	case PARSE_ERROR:
	    R_IoBufferWriteReset(buffer);
	    R_PPStackTop = savestack;
	    SrcFile = NULL;
	    return R_NilValue;
	    break;
	case PARSE_EOF:
	    goto finish;
	    break;
	}
    }
finish:
    R_IoBufferWriteReset(buffer);
    t = CDR(t);
    rval = allocVector(EXPRSXP, length(t));
    for (n = 0 ; n < LENGTH(rval) ; n++, t = CDR(t))
	SET_VECTOR_ELT(rval, n, CAR(t));
    if (SrcFile) {
	rval = attachSrcrefs(rval, SrcFile);
	SrcFile = NULL;
    }
    R_PPStackTop = savestack;
    *status = PARSE_OK;
    return rval;
}


/*----------------------------------------------------------------------------
 *
 *  The Lexical Analyzer:
 *
 *  Basic lexical analysis is performed by the following
 *  routines.  Input is read a line at a time, and, if the
 *  program is in batch mode, each input line is echoed to
 *  standard output after it is read.
 *
 *  The function yylex() scans the input, breaking it into
 *  tokens which are then passed to the parser.  The lexical
 *  analyser maintains a symbol table (in a very messy fashion).
 *
 *  The fact that if statements need to parse differently
 *  depending on whether the statement is being interpreted or
 *  part of the body of a function causes the need for ifpop
 *  and IfPush.  When an if statement is encountered an 'i' is
 *  pushed on a stack (provided there are parentheses active).
 *  At later points this 'i' needs to be popped off of the if
 *  stack.
 *
 */

static void IfPush(void)
{
    if (*contextp==LBRACE ||
	*contextp=='['    ||
	*contextp=='('    ||
	*contextp == 'i') {
	if(contextp - contextstack >= CONTEXTSTACK_SIZE)
	    error(_("contextstack overflow"));
	*++contextp = 'i';
    }

}

static void ifpop(void)
{
    if (*contextp=='i')
	*contextp-- = 0;
}

/* This is only called following ., so we only care if it is
   an ANSI digit or not */
static int typeofnext(void)
{
    int k, c;

    c = xxgetc();
    if (isdigit(c)) k = 1; else k = 2;
    xxungetc(c);
    return k;
}

static int nextchar(int expect)
{
    int c = xxgetc();
    if (c == expect)
	return 1;
    else
	xxungetc(c);
    return 0;
}

/* Special Symbols */
/* Syntactic Keywords + Symbolic Constants */

struct {
    char *name;
    int token;
}
static keywords[] = {
    { "NULL",	    NULL_CONST },
    { "NA",	    NUM_CONST  },
    { "TRUE",	    NUM_CONST  },
    { "FALSE",	    NUM_CONST  },
    { "Inf",	    NUM_CONST  },
    { "NaN",	    NUM_CONST  },
    { "NA_integer_", NUM_CONST  },
    { "NA_real_",    NUM_CONST  },
    { "NA_character_", NUM_CONST  },
    { "NA_complex_", NUM_CONST  },
    { "function",   FUNCTION   },
    { "while",	    WHILE      },
    { "repeat",	    REPEAT     },
    { "for",	    FOR	       },
    { "if",	    IF	       },
    { "in",	    IN	       },
    { "else",	    ELSE       },
    { "next",	    NEXT       },
    { "break",	    BREAK      },
    { "...",	    SYMBOL     },
    { 0,	    0	       }
};

/* KeywordLookup has side effects, it sets yylval */

static int KeywordLookup(const char *s)
{
    int i;
    for (i = 0; keywords[i].name; i++) {
	if (strcmp(keywords[i].name, s) == 0) {
	    switch (keywords[i].token) {
	    case NULL_CONST:
		PROTECT(yylval = R_NilValue);
		break;
	    case NUM_CONST:
		if(GenerateCode) {
		    switch(i) {
		    case 1:
			PROTECT(yylval = mkNA());
			break;
		    case 2:
			PROTECT(yylval = mkTrue());
			break;
		    case 3:
			PROTECT(yylval = mkFalse());
			break;
		    case 4:
			PROTECT(yylval = allocVector(REALSXP, 1));
			REAL(yylval)[0] = R_PosInf;
			break;
		    case 5:
			PROTECT(yylval = allocVector(REALSXP, 1));
			REAL(yylval)[0] = R_NaN;
			break;
		    case 6:
			PROTECT(yylval = allocVector(INTSXP, 1));
			INTEGER(yylval)[0] = NA_INTEGER;
			break;
		    case 7:
			PROTECT(yylval = allocVector(REALSXP, 1));
			REAL(yylval)[0] = NA_REAL;
			break;
		    case 8:
			PROTECT(yylval = allocVector(STRSXP, 1));
			SET_STRING_ELT(yylval, 0, NA_STRING);
			break;
		    case 9:
			PROTECT(yylval = allocVector(CPLXSXP, 1));
			COMPLEX(yylval)[0].r = COMPLEX(yylval)[0].i = NA_REAL;
			break;
		    }
		} else
		    PROTECT(yylval = R_NilValue);
		break;
	    case FUNCTION:
	    case WHILE:
	    case REPEAT:
	    case FOR:
	    case IF:
	    case NEXT:
	    case BREAK:
		yylval = install(s);
		break;
	    case IN:
	    case ELSE:
		break;
	    case SYMBOL:
		PROTECT(yylval = install(s));
		break;
	    }
	    return keywords[i].token;
	}
    }
    return 0;
}

static SEXP mkFloat(const char *s)
{
    return ScalarReal(R_atof(s));
}

static SEXP mkInt(const char *s)
{
    double f = R_atof(s);  /* or R_strtol? */
    return ScalarInteger((int) f);
}


static void yyerror(char *s)
{
    static const char *const yytname_translations[] =
    {
    /* the left column are strings coming from bison, the right
       column are translations for users.
       The first YYENGLISH from the right column are English to be translated,
       the rest are to be copied literally.  The #if 0 block below allows xgettext
       to see these.
    */
#define YYENGLISH 8
	"$undefined",	"input",
	"END_OF_INPUT",	"end of input",
	"ERROR",	"input",
	"STR_CONST",	"string constant",
	"NUM_CONST",	"numeric constant",
	"SYMBOL",	"symbol",
	"LEFT_ASSIGN",	"assignment",
	"'\\n'",	"end of line",
	"NULL_CONST",	"'NULL'",
	"FUNCTION",	"'function'",
	"EQ_ASSIGN",	"'='",
	"RIGHT_ASSIGN",	"'->'",
	"LBB",		"'[['",
	"FOR",		"'for'",
	"IN",		"'in'",
	"IF",		"'if'",
	"ELSE",		"'else'",
	"WHILE",	"'while'",
	"NEXT",		"'next'",
	"BREAK",	"'break'",
	"REPEAT",	"'repeat'",
	"GT",		"'>'",
	"GE",		"'>='",
	"LT",		"'<'",
	"LE",		"'<='",
	"EQ",		"'=='",
	"NE",		"'!='",
	"AND",		"'&'",
	"OR",		"'|'",
	"AND2",		"'&&'",
	"OR2",		"'||'",
	"NS_GET",	"'::'",
	"NS_GET_INT",	"':::'",
	0
    };
    static char const yyunexpected[] = "syntax error, unexpected ";
    static char const yyexpecting[] = ", expecting ";
    char *expecting;
 #if 0
 /* these are just here to trigger the internationalization */
    _("input");
    _("end of input");
    _("string constant");
    _("numeric constant");
    _("symbol");
    _("assignment");
    _("end of line");
#endif

    R_ParseError     = yylloc.first_line;
    R_ParseErrorCol  = yylloc.first_column;
    R_ParseErrorFile = SrcFile;

    if (!strncmp(s, yyunexpected, sizeof yyunexpected -1)) {
	int i;
	/* Edit the error message */
	expecting = strstr(s + sizeof yyunexpected -1, yyexpecting);
	if (expecting) *expecting = '\0';
	for (i = 0; yytname_translations[i]; i += 2) {
	    if (!strcmp(s + sizeof yyunexpected - 1, yytname_translations[i])) {
		sprintf(R_ParseErrorMsg, _("unexpected %s"),
		    i/2 < YYENGLISH ? _(yytname_translations[i+1])
				    : yytname_translations[i+1]);
		return;
	    }
	}
	sprintf(R_ParseErrorMsg, _("unexpected %s"), s + sizeof yyunexpected - 1);
    } else {
	strncpy(R_ParseErrorMsg, s, PARSE_ERROR_SIZE - 1);
    }
}

static void CheckFormalArgs(SEXP formlist, SEXP _new, YYLTYPE *lloc)
{
    while (formlist != R_NilValue) {
	if (TAG(formlist) == _new) {
	    error(_("Repeated formal argument '%s' on line %d"), CHAR(PRINTNAME(_new)),
								 lloc->first_line);
	}
	formlist = CDR(formlist);
    }
}

/* This is used as the buffer for NumericValue, SpecialValue and
   SymbolValue.  None of these could conceivably need 8192 bytes.

   It has not been used as the buffer for input character strings
   since Oct 2007 (released as 2.7.0), and for comments since 2.8.0
 */
static char yytext[MAXELTSIZE];

#define DECLARE_YYTEXT_BUFP(bp) char *bp = yytext
#define YYTEXT_PUSH(c, bp) do { \
    if ((bp) - yytext >= sizeof(yytext) - 1) \
	error(_("input buffer overflow at line %d"), xxlineno); \
	*(bp)++ = (c); \
} while(0)

static int SkipSpace(void)
{
    int c;

#ifdef Win32
    if(!mbcslocale) { /* 0xa0 is NBSP in all 8-bit Windows locales */
	while ((c = xxgetc()) == ' ' || c == '\t' || c == '\f' ||
	       (unsigned int) c == 0xa0) ;
	return c;
    } else {
	int i, clen;
	wchar_t wc;
	while (1) {
	    c = xxgetc();
	    if (c == ' ' || c == '\t' || c == '\f') continue;
	    if (c == '\n' || c == R_EOF) break;
	    if ((unsigned int) c < 0x80) break;
	    clen = mbcs_get_next(c, &wc);  /* always 2 */
	    if(! Ri18n_iswctype(wc, Ri18n_wctype("blank")) ) break;
	    for(i = 1; i < clen; i++) c = xxgetc();
	}
	return c;
    }
#endif
#if defined(SUPPORT_MBCS) && defined(__STDC_ISO_10646__)
    if(mbcslocale) { /* wctype functions need Unicode wchar_t */
	int i, clen;
	wchar_t wc;
	while (1) {
	    c = xxgetc();
	    if (c == ' ' || c == '\t' || c == '\f') continue;
	    if (c == '\n' || c == R_EOF) break;
	    if ((unsigned int) c < 0x80) break;
	    clen = mbcs_get_next(c, &wc);
	    if(! Ri18n_iswctype(wc, Ri18n_wctype("blank")) ) break;
	    for(i = 1; i < clen; i++) c = xxgetc();
	}
    } else
#endif
	while ((c = xxgetc()) == ' ' || c == '\t' || c == '\f') ;
    return c;
}

/* Note that with interactive use, EOF cannot occur inside */
/* a comment.  However, semicolons inside comments make it */
/* appear that this does happen.  For this reason we use the */
/* special assignment EndOfFile=2 to indicate that this is */
/* going on.  This is detected and dealt with in Parse1Buffer. */

static int SkipComment(void)
{
    int c;
    while ((c = xxgetc()) != '\n' && c != R_EOF) ;
    if (c == R_EOF) EndOfFile = 2;
    return c;
}

static int NumericValue(int c)
{
    int seendot = (c == '.');
    int seenexp = 0;
    int last = c;
    int nd = 0;
    int asNumeric = 0;

    DECLARE_YYTEXT_BUFP(yyp);
    YYTEXT_PUSH(c, yyp);
    /* We don't care about other than ASCII digits */
    while (isdigit(c = xxgetc()) || c == '.' || c == 'e' || c == 'E'
	   || c == 'x' || c == 'X' || c == 'L')
    {
	if (c == 'L') /* must be at the end.  Won't allow 1Le3 (at present). */
	    break;

	if (c == 'x' || c == 'X') {
	    if (last != '0') break;
	    YYTEXT_PUSH(c, yyp);
	    while(isdigit(c = xxgetc()) || ('a' <= c && c <= 'f') ||
		  ('A' <= c && c <= 'F') || c == '.') {
		YYTEXT_PUSH(c, yyp);
		nd++;
	    }
	    if (nd == 0) return ERROR;
	    if (c == 'p' || c == 'P') {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
		if (!isdigit(c) && c != '+' && c != '-') return ERROR;
		if (c == '+' || c == '-') {
		    YYTEXT_PUSH(c, yyp);
		    c = xxgetc();
		}
		for(nd = 0; isdigit(c); c = xxgetc(), nd++)
		    YYTEXT_PUSH(c, yyp);
		if (nd == 0) return ERROR;
	    }
	    break;
	}
	if (c == 'E' || c == 'e') {
	    if (seenexp)
		break;
	    seenexp = 1;
	    seendot = seendot == 1 ? seendot : 2;
	    YYTEXT_PUSH(c, yyp);
	    c = xxgetc();
	    if (!isdigit(c) && c != '+' && c != '-') return ERROR;
	    if (c == '+' || c == '-') {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
		if (!isdigit(c)) return ERROR;
	    }
	}
	if (c == '.') {
	    if (seendot)
		break;
	    seendot = 1;
	}
	YYTEXT_PUSH(c, yyp);
	last = c;
    }
    YYTEXT_PUSH('\0', yyp);
    /* Make certain that things are okay. */
    if(c == 'L') {
	double a = R_atof(yytext);
	int b = (int) a;
	/* We are asked to create an integer via the L, so we check that the
	   double and int values are the same. If not, this is a problem and we
	   will not lose information and so use the numeric value.
	*/
	if(a != (double) b) {
	    if(GenerateCode) {
		if(seendot == 1 && seenexp == 0)
		    warning(_("integer literal %sL contains decimal; using numeric value"), yytext);
		else
		    warning(_("non-integer value %s qualified with L; using numeric value"), yytext);
	    }
	    asNumeric = 1;
	    seenexp = 1;
	}
    }

    if(c == 'i') {
	yylval = GenerateCode ? mkComplex(yytext) : R_NilValue;
    } else if(c == 'L' && asNumeric == 0) {
	if(GenerateCode && seendot == 1 && seenexp == 0)
	    warning(_("integer literal %sL contains unnecessary decimal point"), yytext);
	yylval = GenerateCode ? mkInt(yytext) : R_NilValue;
#if 0  /* do this to make 123 integer not double */
    } else if(!(seendot || seenexp)) {
	if(c != 'L') xxungetc(c);
	if (GenerateCode) {
	    double a = R_atof(yytext);
	    int b = (int) a;
	    yylval = (a != (double) b) ? mkFloat(yytext) : mkInt(yytext);
	} else yylval = R_NilValue;
#endif
    } else {
	if(c != 'L')
	    xxungetc(c);
	yylval = GenerateCode ? mkFloat(yytext) : R_NilValue;
    }

    PROTECT(yylval);
    return NUM_CONST;
}

/* Strings may contain the standard ANSI escapes and octal */
/* specifications of the form \o, \oo or \ooo, where 'o' */
/* is an octal digit. */


#define STEXT_PUSH(c) do {                  \
	unsigned int nc = bp - stext;       \
	if (nc >= nstext - 1) {             \
	    char *old = stext;              \
	    nstext *= 2;                    \
	    stext = malloc(nstext);         \
	    if(!stext) error(_("unable to allocate buffer for long string at line %d"), xxlineno);\
	    memmove(stext, old, nc);        \
	    if(old != st0) free(old);	    \
	    bp = stext+nc; }		    \
	*bp++ = (c);                        \
} while(0)


/* The idea here is that if a string contains \u escapes that are not
   valid in the current locale, we should switch to UTF-8 for that
   string.  Needs wide-char support.
*/
#ifdef SUPPORT_MBCS
# ifdef Win32
#  define USE_UTF8_IF_POSSIBLE
# endif
#endif

#ifdef USE_UTF8_IF_POSSIBLE
#define WTEXT_PUSH(c) do { if(wcnt < 1000) wcs[wcnt++] = c; } while(0)

static SEXP mkStringUTF8(const wchar_t *wcs, int cnt)
{
    SEXP t;
    char *s;
    int nb;

/* NB: cnt includes the terminator */
#ifdef Win32
    nb = cnt*4; /* UCS-2/UTF-16 so max 4 bytes per wchar_t */
#else
    nb = cnt*6;
#endif
    s = alloca(nb);
    R_CheckStack();
    memset(s, 0, nb); /* safety */
    wcstoutf8(s, wcs, nb);
    PROTECT(t = allocVector(STRSXP, 1));
    SET_STRING_ELT(t, 0, mkCharCE(s, CE_UTF8));
    UNPROTECT(1);
    return t;
}
#else
#define WTEXT_PUSH(c)
#endif

#define CTEXT_PUSH(c) do { \
	if (ct - currtext >= 1000) {memmove(currtext, currtext+100, 901); memmove(currtext, "... ", 4); ct -= 100;} \
	*ct++ = (c); \
} while(0)
#define CTEXT_POP() ct--


static int StringValue(int c, Rboolean forSymbol)
{
    int quote = c;
    int have_warned = 0;
    char currtext[1010], *ct = currtext;
    char st0[MAXELTSIZE];
    unsigned int nstext = MAXELTSIZE;
    char *stext = st0, *bp = st0;

#ifdef USE_UTF8_IF_POSSIBLE
    int wcnt = 0;
    wchar_t wcs[1001];
    Rboolean use_wcs = FALSE;
#endif

    while ((c = xxgetc()) != R_EOF && c != quote) {
	CTEXT_PUSH(c);
	if (c == '\n') {
	    xxungetc(c);
	    /* Fix by Mark Bravington to allow multiline strings
	     * by pretending we've seen a backslash. Was:
	     * return ERROR;
	     */
	    c = '\\';
	}
	if (c == '\\') {
	    c = xxgetc(); CTEXT_PUSH(c);
	    if ('0' <= c && c <= '8') {
		int octal = c - '0';
		if ('0' <= (c = xxgetc()) && c <= '8') {
		    CTEXT_PUSH(c);
		    octal = 8 * octal + c - '0';
		    if ('0' <= (c = xxgetc()) && c <= '8') {
			CTEXT_PUSH(c);
			octal = 8 * octal + c - '0';
		    } else {
			xxungetc(c);
			CTEXT_POP();
		    }
		} else {
		    xxungetc(c);
		    CTEXT_POP();
		}
		c = octal;
	    }
	    else if(c == 'x') {
		int val = 0; int i, ext;
		for(i = 0; i < 2; i++) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if(c >= '0' && c <= '9') ext = c - '0';
		    else if (c >= 'A' && c <= 'F') ext = c - 'A' + 10;
		    else if (c >= 'a' && c <= 'f') ext = c - 'a' + 10;
		    else {
			xxungetc(c);
			CTEXT_POP();
			if (i == 0) { /* was just \x */
			    if(GenerateCode && R_WarnEscapes) {
				have_warned++;
				warningcall(R_NilValue, _("'\\x' used without hex digits"));
			    }
			    val = 'x';
			}
			break;
		    }
		    val = 16*val + ext;
		}
		c = val;
	    }
	    else if(c == 'u') {
#ifndef SUPPORT_MBCS
		error(_("\\uxxxx sequences not supported (line %d)"), xxlineno);
#else
		unsigned int val = 0; int i, ext; size_t res;
		char buff[MB_CUR_MAX+1]; /* could be variable, and hence not legal C90 */
		Rboolean delim = FALSE;
		if((c = xxgetc()) == '{') {
		    delim = TRUE;
		    CTEXT_PUSH(c);
		} else xxungetc(c);
		for(i = 0; i < 4; i++) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if(c >= '0' && c <= '9') ext = c - '0';
		    else if (c >= 'A' && c <= 'F') ext = c - 'A' + 10;
		    else if (c >= 'a' && c <= 'f') ext = c - 'a' + 10;
		    else {
			xxungetc(c);
			CTEXT_POP();
			if (i == 0) { /* was just \x */
			    if(GenerateCode && R_WarnEscapes) {
				have_warned++;
				warningcall(R_NilValue, _("\\u used without hex digits"));
			    }
			    val = 'u';
			}
			break;
		    }
		    val = 16*val + ext;
		}
		if(delim) {
		    if((c = xxgetc()) != '}')
			error(_("invalid \\u{xxxx} sequence (line %d)"), xxlineno);
		    else CTEXT_PUSH(c);
		}
		WTEXT_PUSH(val);
		res = ucstomb(buff, val);
		if((int) res <= 0) {
#ifdef USE_UTF8_IF_POSSIBLE
		    if(!forSymbol) {
			use_wcs = TRUE;
		    } else
#endif
		    {
			if(delim)
			    error(_("invalid \\u{xxxx} sequence (line %d)"), xxlineno);
			else
			    error(_("invalid \\uxxxx sequence (line %d)"), xxlineno);
		    }
		} else
		    for(i = 0; i <  res; i++) STEXT_PUSH(buff[i]);
		continue;
#endif
	    }
	    else if(c == 'U') {
#ifndef SUPPORT_MBCS
		error(_("\\Uxxxxxxxx sequences not supported (line %d)"), xxlineno);
#else
		unsigned int val = 0; int i, ext; size_t res;
		char buff[MB_CUR_MAX+1]; /* could be variable, and hence not legal C90 */
		Rboolean delim = FALSE;
		if((c = xxgetc()) == '{') {
		    delim = TRUE;
		    CTEXT_PUSH(c);
		} else xxungetc(c);
		for(i = 0; i < 8; i++) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if(c >= '0' && c <= '9') ext = c - '0';
		    else if (c >= 'A' && c <= 'F') ext = c - 'A' + 10;
		    else if (c >= 'a' && c <= 'f') ext = c - 'a' + 10;
		    else {
			xxungetc(c);
			CTEXT_POP();
			if (i == 0) { /* was just \x */
			    if(GenerateCode && R_WarnEscapes) {
				have_warned++;
				warningcall(R_NilValue, _("\\U used without hex digits"));
			    }
			    val = 'U';
			}
			break;
		    }
		    val = 16*val + ext;
		}
		if(delim) {
		    if((c = xxgetc()) != '}')
			error(_("invalid \\U{xxxxxxxx} sequence (line %d)"), xxlineno);
		    else CTEXT_PUSH(c);
		}
		res = ucstomb(buff, val);
		if((int)res <= 0) {
		    if(delim)
			error(_("invalid \\U{xxxxxxxx} sequence (line %d)"), xxlineno);
		    else
			error(_("invalid \\Uxxxxxxxx sequence (line %d)"), xxlineno);
		}
		for(i = 0; i <  res; i++) STEXT_PUSH(buff[i]);
		WTEXT_PUSH(val);
		continue;
#endif
	    }
	    else {
		switch (c) {
		case 'a':
		    c = '\a';
		    break;
		case 'b':
		    c = '\b';
		    break;
		case 'f':
		    c = '\f';
		    break;
		case 'n':
		    c = '\n';
		    break;
		case 'r':
		    c = '\r';
		    break;
		case 't':
		    c = '\t';
		    break;
		case 'v':
		    c = '\v';
		    break;
		case '\\':
		    c = '\\';
		    break;
		case '"':
		case '\'':
		case ' ':
		case '\n':
		    break;
		default:
		    if(GenerateCode && R_WarnEscapes) {
			have_warned++;
			warningcall(R_NilValue, _("'\\%c' is an unrecognized escape in a character string"), c);
		    }
		    break;
		}
	    }
	}
#if defined(SUPPORT_MBCS)
       else if(mbcslocale) {
	   int i, clen;
	   wchar_t wc = L'\0';
	   /* We can't assume this is valid UTF-8 */
	   clen = /* utf8locale ? utf8clen(c):*/ mbcs_get_next(c, &wc);
	   WTEXT_PUSH(wc);
	   for(i = 0; i < clen - 1; i++){
	       STEXT_PUSH(c);
	       c = xxgetc();
	       if (c == R_EOF) break;
	       CTEXT_PUSH(c);
	       if (c == '\n') {
		   xxungetc(c); CTEXT_POP();
		   c = '\\';
	       }
	   }
	   if (c == R_EOF) break;
	   STEXT_PUSH(c);
	   continue;
       }
#endif /* SUPPORT_MBCS */
	STEXT_PUSH(c);
#ifdef USE_UTF8_IF_POSSIBLE
	if ((unsigned int) c < 0x80) WTEXT_PUSH(c);
	else { /* have an 8-bit char in the current encoding */
	    wchar_t wc;
	    char s[2] = " ";
	    s[0] = c;
	    mbrtowc(&wc, s, 1, NULL);
	    WTEXT_PUSH(wc);
	}
#endif
    }
    STEXT_PUSH('\0');
    WTEXT_PUSH(0);
    if(forSymbol) {
	PROTECT(yylval = install(stext));
	if(stext != st0) free(stext);
	return SYMBOL;
    } else {
#ifdef USE_UTF8_IF_POSSIBLE
	if(use_wcs) {
	    if(wcnt < 1000)
		PROTECT(yylval = mkStringUTF8(wcs, wcnt)); /* include terminator */
	    else
		error(_("string at line %d containing Unicode escapes not in this locale\nis too long (max 1000 chars)"), xxlineno);
	} else
#endif
	    PROTECT(yylval = mkString2(stext,  bp - stext - 1));
	if(stext != st0) free(stext);
	if(have_warned) {
	    *ct = '\0';
#ifdef ENABLE_NLS
	    warningcall(R_NilValue,
			ngettext("unrecognized escape removed from \"%s\"",
				 "unrecognized escapes removed from \"%s\"",
				 have_warned),
			currtext);
#else
	    warningcall(R_NilValue,
			"unrecognized escape(s) removed from \"%s\"", currtext);
#endif
	}
	return STR_CONST;
    }
}

static int SpecialValue(int c)
{
    DECLARE_YYTEXT_BUFP(yyp);
    YYTEXT_PUSH(c, yyp);
    while ((c = xxgetc()) != R_EOF && c != '%') {
	if (c == '\n') {
	    xxungetc(c);
	    return ERROR;
	}
	YYTEXT_PUSH(c, yyp);
    }
    if (c == '%')
	YYTEXT_PUSH(c, yyp);
    YYTEXT_PUSH('\0', yyp);
    yylval = install(yytext);
    return SPECIAL;
}

/* return 1 if name is a valid name 0 otherwise */
int isValidName(const char *name)
{
    const char *p = name;
    int i;

#ifdef SUPPORT_MBCS
    if(mbcslocale) {
	/* the only way to establish which chars are alpha etc is to
	   use the wchar variants */
	int n = strlen(name), used;
	wchar_t wc;
	used = Mbrtowc(&wc, p, n, NULL); p += used; n -= used;
	if(used == 0) return 0;
	if (wc != L'.' && !iswalpha(wc) ) return 0;
	if (wc == L'.') {
	    /* We don't care about other than ASCII digits */
	    if(isdigit(0xff & (int)*p)) return 0;
	    /* Mbrtowc(&wc, p, n, NULL); if(iswdigit(wc)) return 0; */
	}
	while((used = Mbrtowc(&wc, p, n, NULL))) {
	    if (!(iswalnum(wc) || wc == L'.' || wc == L'_')) break;
	    p += used; n -= used;
	}
	if (*p != '\0') return 0;
    } else
#endif
    {
	int c = 0xff & *p++;
	if (c != '.' && !isalpha(c) ) return 0;
	if (c == '.' && isdigit(0xff & (int)*p)) return 0;
	while ( c = 0xff & *p++, (isalnum(c) || c == '.' || c == '_') ) ;
	if (c != '\0') return 0;
    }

    if (strcmp(name, "...") == 0) return 1;

    for (i = 0; keywords[i].name != NULL; i++)
	if (strcmp(keywords[i].name, name) == 0) return 0;

    return 1;
}


static int SymbolValue(int c)
{
    int kw;
    DECLARE_YYTEXT_BUFP(yyp);
#if defined(SUPPORT_MBCS)
    if(mbcslocale) {
	wchar_t wc; int i, clen;
	   /* We can't assume this is valid UTF-8 */
	clen = /* utf8locale ? utf8clen(c) :*/ mbcs_get_next(c, &wc);
	while(1) {
	    /* at this point we have seen one char, so push its bytes
	       and get one more */
	    for(i = 0; i < clen; i++) {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
	    }
	    if(c == R_EOF) break;
	    if(c == '.' || c == '_') {
		clen = 1;
		continue;
	    }
	    clen = mbcs_get_next(c, &wc);
	    if(!iswalnum(wc)) break;
	}
    } else
#endif
	do {
	    YYTEXT_PUSH(c, yyp);
	} while ((c = xxgetc()) != R_EOF &&
		 (isalnum(c) || c == '.' || c == '_'));
    xxungetc(c);
    YYTEXT_PUSH('\0', yyp);
    if ((kw = KeywordLookup(yytext))) {
	if ( kw == FUNCTION ) {
	    if (FunctionLevel >= MAXNEST)
		error(_("functions nested too deeply in source code at line %d"), xxlineno);
	    if ( FunctionLevel++ == 0 && GenerateCode) {
		strcpy((char *)FunctionSource, "function");
		SourcePtr = FunctionSource + 8;
	    }
	    FunctionStart[FunctionLevel] = SourcePtr - 8;
#if 0
	    printf("%d,%d\n", SourcePtr - FunctionSource, FunctionLevel);
#endif
	}
	return kw;
    }
    PROTECT(yylval = install(yytext));
    return SYMBOL;
}

/* Split the input stream into tokens. */
/* This is the lowest of the parsing levels. */

static int token(void)
{
    int c;
#if defined(SUPPORT_MBCS)
    wchar_t wc;
#endif

    if (SavedToken) {
	c = SavedToken;
	yylval = SavedLval;
	SavedLval = R_NilValue;
	SavedToken = 0;
	yylloc.first_line = xxlinesave;
	yylloc.first_column = xxcolsave;
	yylloc.first_byte = xxbytesave;
	return c;
    }
    xxcharsave = xxcharcount; /* want to be able to go back one token */

    c = SkipSpace();
    if (c == '#') c = SkipComment();

    yylloc.first_line = xxlineno;
    yylloc.first_column = xxcolno;
    yylloc.first_byte = xxbyteno;

    if (c == R_EOF) return END_OF_INPUT;

    /* Either digits or symbols can start with a "." */
    /* so we need to decide which it is and jump to  */
    /* the correct spot. */

    if (c == '.' && typeofnext() >= 2) goto symbol;

    /* literal numbers */

    if (c == '.') return NumericValue(c);
    /* We don't care about other than ASCII digits */
    if (isdigit(c)) return NumericValue(c);

    /* literal strings */

    if (c == '\"' || c == '\'')
	return StringValue(c, FALSE);

    /* special functions */

    if (c == '%')
	return SpecialValue(c);

    /* functions, constants and variables */

    if (c == '`')
	return StringValue(c, TRUE);
 symbol:

    if (c == '.') return SymbolValue(c);
#if defined(SUPPORT_MBCS)
    if(mbcslocale) {
	mbcs_get_next(c, &wc);
	if (iswalpha(wc)) return SymbolValue(c);
    } else
#endif
	if (isalpha(c)) return SymbolValue(c);

    /* compound tokens */

    switch (c) {
    case '<':
	if (nextchar('=')) {
	    yylval = install("<=");
	    return LE;
	}
	if (nextchar('-')) {
	    yylval = install("<-");
	    return LEFT_ASSIGN;
	}
	if (nextchar('<')) {
	    if (nextchar('-')) {
		yylval = install("<<-");
		return LEFT_ASSIGN;
	    }
	    else
		return ERROR;
	}
	yylval = install("<");
	return LT;
    case '-':
	if (nextchar('>')) {
	    if (nextchar('>')) {
		yylval = install("<<-");
		return RIGHT_ASSIGN;
	    }
	    else {
		yylval = install("<-");
		return RIGHT_ASSIGN;
	    }
	}
	yylval = install("-");
	return '-';
    case '>':
	if (nextchar('=')) {
	    yylval = install(">=");
	    return GE;
	}
	yylval = install(">");
	return GT;
    case '!':
	if (nextchar('=')) {
	    yylval = install("!=");
	    return NE;
	}
	yylval = install("!");
	return '!';
    case '=':
	if (nextchar('=')) {
	    yylval = install("==");
	    return EQ;
	}
	yylval = install("=");
	return EQ_ASSIGN;
    case ':':
	if (nextchar(':')) {
	    if (nextchar(':')) {
		yylval = install(":::");
		return NS_GET_INT;
	    }
	    else {
		yylval = install("::");
		return NS_GET;
	    }
	}
	if (nextchar('=')) {
	    yylval = install(":=");
	    return LEFT_ASSIGN;
	}
	yylval = install(":");
	return ':';
    case '&':
	if (nextchar('&')) {
	    yylval = install("&&");
	    return AND2;
	}
	yylval = install("&");
	return AND;
    case '|':
	if (nextchar('|')) {
	    yylval = install("||");
	    return OR2;
	}
	yylval = install("|");
	return OR;
    case LBRACE:
	yylval = install("{");
	return c;
    case RBRACE:
	return c;
    case '(':
	yylval = install("(");
	return c;
    case ')':
	return c;
    case '[':
	if (nextchar('[')) {
	    yylval = install("[[");
	    return LBB;
	}
	yylval = install("[");
	return c;
    case ']':
	return c;
    case '?':
	strcpy(yytext, "?");
	yylval = install(yytext);
	return c;
    case '*':
	/* Replace ** by ^.  This has been here since 1998, but is
	   undocumented (at least in the obvious places).  It is in
	   the index of the Blue Book with a reference to p. 431, the
	   help for 'Deprecated'.  S-PLUS 6.2 still allowed this, so
	   presumably it was for compatibility with S. */
	if (nextchar('*'))
	    c='^';
	yytext[0] = c;
	yytext[1] = '\0';
	yylval = install(yytext);
	return c;
    case '+':
    case '/':
    case '^':
    case '~':
    case '$':
    case '@':
	yytext[0] = c;
	yytext[1] = '\0';
	yylval = install(yytext);
	return c;
    default:
	return c;
    }
}

static void setlastloc(void)
{
    yylloc.last_line = xxlineno;
    yylloc.last_column = xxcolno;
    yylloc.last_byte = xxbyteno;
}

static int yylex(void)
{
    int tok;

 again:

    tok = token();

    /* Newlines must be handled in a context */
    /* sensitive way.  The following block of */
    /* deals directly with newlines in the */
    /* body of "if" statements. */

    if (tok == '\n') {

	if (EatLines || *contextp == '[' || *contextp == '(')
	    goto again;

	/* The essence of this is that in the body of */
	/* an "if", any newline must be checked to */
	/* see if it is followed by an "else". */
	/* such newlines are discarded. */

	if (*contextp == 'i') {

	    /* Find the next non-newline token */

	    while(tok == '\n')
		tok = token();

	    /* If we encounter "}", ")" or "]" then */
	    /* we know that all immediately preceding */
	    /* "if" bodies have been terminated. */
	    /* The corresponding "i" values are */
	    /* popped off the context stack. */

	    if (tok == RBRACE || tok == ')' || tok == ']' ) {
		while (*contextp == 'i')
		    ifpop();
		*contextp-- = 0;
		setlastloc();
		return tok;
	    }

	    /* When a "," is encountered, it terminates */
	    /* just the immediately preceding "if" body */
	    /* so we pop just a single "i" of the */
	    /* context stack. */

	    if (tok == ',') {
		ifpop();
		setlastloc();
		return tok;
	    }

	    /* Tricky! If we find an "else" we must */
	    /* ignore the preceding newline.  Any other */
	    /* token means that we must return the newline */
	    /* to terminate the "if" and "push back" that */
	    /* token so that we will obtain it on the next */
	    /* call to token.  In either case sensitivity */
	    /* is lost, so we pop the "i" from the context */
	    /* stack. */

	    if(tok == ELSE) {
		EatLines = 1;
		ifpop();
		setlastloc();
		return ELSE;
	    }
	    else {
		ifpop();
		SavedToken = tok;
		xxlinesave = yylloc.first_line;
		xxcolsave  = yylloc.first_column;
		xxbytesave = yylloc.first_byte;
		SavedLval = yylval;
		setlastloc();
		return '\n';
	    }
	}
	else {
	    setlastloc();
	    return '\n';
	}
    }

    /* Additional context sensitivities */

    switch(tok) {

	/* Any newlines immediately following the */
	/* the following tokens are discarded. The */
	/* expressions are clearly incomplete. */

    case '+':
    case '-':
    case '*':
    case '/':
    case '^':
    case LT:
    case LE:
    case GE:
    case GT:
    case EQ:
    case NE:
    case OR:
    case AND:
    case OR2:
    case AND2:
    case SPECIAL:
    case FUNCTION:
    case WHILE:
    case REPEAT:
    case FOR:
    case IN:
    case '?':
    case '!':
    case '=':
    case ':':
    case '~':
    case '$':
    case '@':
    case LEFT_ASSIGN:
    case RIGHT_ASSIGN:
    case EQ_ASSIGN:
	EatLines = 1;
	break;

	/* Push any "if" statements found and */
	/* discard any immediately following newlines. */

    case IF:
	IfPush();
	EatLines = 1;
	break;

	/* Terminate any immediately preceding "if" */
	/* statements and discard any immediately */
	/* following newlines. */

    case ELSE:
	ifpop();
	EatLines = 1;
	break;

	/* These tokens terminate any immediately */
	/* preceding "if" statements. */

    case ';':
    case ',':
	ifpop();
	break;

	/* Any newlines following these tokens can */
	/* indicate the end of an expression. */

    case SYMBOL:
    case STR_CONST:
    case NUM_CONST:
    case NULL_CONST:
    case NEXT:
    case BREAK:
	EatLines = 0;
	break;

	/* Handle brackets, braces and parentheses */

    case LBB:
	if(contextp - contextstack >= CONTEXTSTACK_SIZE - 1)
	    error(_("contextstack overflow at line %d"), xxlineno);
	*++contextp = '[';
	*++contextp = '[';
	break;

    case '[':
	if(contextp - contextstack >= CONTEXTSTACK_SIZE)
	    error(_("contextstack overflow at line %d"), xxlineno);
	*++contextp = tok;
	break;

    case LBRACE:
	if(contextp - contextstack >= CONTEXTSTACK_SIZE)
	    error(_("contextstack overflow at line %d"), xxlineno);
	*++contextp = tok;
	EatLines = 1;
	break;

    case '(':
	if(contextp - contextstack >= CONTEXTSTACK_SIZE)
	    error(_("contextstack overflow at line %d"), xxlineno);
	*++contextp = tok;
	break;

    case ']':
	while (*contextp == 'i')
	    ifpop();
	*contextp-- = 0;
	EatLines = 0;
	break;

    case RBRACE:
	while (*contextp == 'i')
	    ifpop();
	*contextp-- = 0;
	break;

    case ')':
	while (*contextp == 'i')
	    ifpop();
	*contextp-- = 0;
	EatLines = 0;
	break;

    }
    setlastloc();
    return tok;
}
#line 3338 "y.tab.c"
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack(void)
{
    int newsize, i;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = yyssp - yyss;
    newss = (yyss != 0)
          ? (short *)realloc(yyss, newsize * sizeof(*newss))
          : (short *)malloc(newsize * sizeof(*newss));
    if (newss == 0)
        return -1;

    yyss  = newss;
    yyssp = newss + i;
    newvs = (yyvs != 0)
          ? (YYSTYPE *)realloc(yyvs, newsize * sizeof(*newvs))
          : (YYSTYPE *)malloc(newsize * sizeof(*newvs));
    if (newvs == 0)
        return -1;

    yyvs = newvs;
    yyvsp = newvs + i;
    yystacksize = newsize;
    yysslim = yyss + newsize - 1;
    return 0;
}

#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse(void)
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register const char *yys;

    if ((yys = getenv("YYDEBUG")) != 0)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = YYEMPTY;

    if (yyss == NULL && yygrowstack()) goto yyoverflow;
    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yysslim && yygrowstack())
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = YYEMPTY;
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;

    yyerror("syntax error");

#ifdef lint
    goto yyerrlab;
#endif

yyerrlab:
    ++yynerrs;

yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yysslim && yygrowstack())
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = YYEMPTY;
        goto yyloop;
    }

yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    if (yym)
        yyval = yyvsp[1-yym];
    else
        memset(&yyval, 0, sizeof yyval);
    switch (yyn)
    {
case 1:
#line 239 "../gram.y"
{ return 0; }
break;
case 2:
#line 240 "../gram.y"
{ return xxvalue(NULL,2,NULL); }
break;
case 3:
#line 241 "../gram.y"
{ return xxvalue(yyvsp[-1],3,&@1); }
break;
case 4:
#line 242 "../gram.y"
{ return xxvalue(yyvsp[-1],4,&@1); }
break;
case 5:
#line 243 "../gram.y"
{ YYABORT; }
break;
case 6:
#line 246 "../gram.y"
{ yyval = yyvsp[0]; }
break;
case 7:
#line 247 "../gram.y"
{ yyval = yyvsp[0]; }
break;
case 8:
#line 250 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 9:
#line 253 "../gram.y"
{ yyval = yyvsp[0]; }
break;
case 10:
#line 254 "../gram.y"
{ yyval = yyvsp[0]; }
break;
case 11:
#line 255 "../gram.y"
{ yyval = yyvsp[0]; }
break;
case 12:
#line 256 "../gram.y"
{ yyval = yyvsp[0]; }
break;
case 13:
#line 258 "../gram.y"
{ yyval = xxexprlist(yyvsp[-2],&@1,yyvsp[-1]); }
break;
case 14:
#line 259 "../gram.y"
{ yyval = xxparen(yyvsp[-2],yyvsp[-1]); }
break;
case 15:
#line 261 "../gram.y"
{ yyval = xxunary(yyvsp[-1],yyvsp[0]); }
break;
case 16:
#line 262 "../gram.y"
{ yyval = xxunary(yyvsp[-1],yyvsp[0]); }
break;
case 17:
#line 263 "../gram.y"
{ yyval = xxunary(yyvsp[-1],yyvsp[0]); }
break;
case 18:
#line 264 "../gram.y"
{ yyval = xxunary(yyvsp[-1],yyvsp[0]); }
break;
case 19:
#line 265 "../gram.y"
{ yyval = xxunary(yyvsp[-1],yyvsp[0]); }
break;
case 20:
#line 267 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 21:
#line 268 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 22:
#line 269 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 23:
#line 270 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 24:
#line 271 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 25:
#line 272 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 26:
#line 273 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 27:
#line 274 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 28:
#line 275 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 29:
#line 276 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 30:
#line 277 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 31:
#line 278 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 32:
#line 279 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 33:
#line 280 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 34:
#line 281 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 35:
#line 282 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 36:
#line 283 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 37:
#line 284 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 38:
#line 285 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 39:
#line 286 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 40:
#line 288 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 41:
#line 289 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[0],yyvsp[-2]); }
break;
case 42:
#line 291 "../gram.y"
{ yyval = xxdefun(yyvsp[-5],yyvsp[-3],yyvsp[0]); }
break;
case 43:
#line 292 "../gram.y"
{ yyval = xxfuncall(yyvsp[-3],yyvsp[-1]); }
break;
case 44:
#line 293 "../gram.y"
{ yyval = xxif(yyvsp[-2],yyvsp[-1],yyvsp[0]); }
break;
case 45:
#line 294 "../gram.y"
{ yyval = xxifelse(yyvsp[-4],yyvsp[-3],yyvsp[-2],yyvsp[0]); }
break;
case 46:
#line 295 "../gram.y"
{ yyval = xxfor(yyvsp[-2],yyvsp[-1],yyvsp[0]); }
break;
case 47:
#line 296 "../gram.y"
{ yyval = xxwhile(yyvsp[-2],yyvsp[-1],yyvsp[0]); }
break;
case 48:
#line 297 "../gram.y"
{ yyval = xxrepeat(yyvsp[-1],yyvsp[0]); }
break;
case 49:
#line 298 "../gram.y"
{ yyval = xxsubscript(yyvsp[-4],yyvsp[-3],yyvsp[-2]); }
break;
case 50:
#line 299 "../gram.y"
{ yyval = xxsubscript(yyvsp[-3],yyvsp[-2],yyvsp[-1]); }
break;
case 51:
#line 300 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 52:
#line 301 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 53:
#line 302 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 54:
#line 303 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 55:
#line 304 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 56:
#line 305 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 57:
#line 306 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 58:
#line 307 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 59:
#line 308 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 60:
#line 309 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 61:
#line 310 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 62:
#line 311 "../gram.y"
{ yyval = xxbinary(yyvsp[-1],yyvsp[-2],yyvsp[0]); }
break;
case 63:
#line 312 "../gram.y"
{ yyval = xxnxtbrk(yyvsp[0]); }
break;
case 64:
#line 313 "../gram.y"
{ yyval = xxnxtbrk(yyvsp[0]); }
break;
case 65:
#line 317 "../gram.y"
{ yyval = xxcond(yyvsp[-1]); }
break;
case 66:
#line 320 "../gram.y"
{ yyval = xxifcond(yyvsp[-1]); }
break;
case 67:
#line 323 "../gram.y"
{ yyval = xxforcond(yyvsp[-3],yyvsp[-1]); }
break;
case 68:
#line 327 "../gram.y"
{ yyval = xxexprlist0(); }
break;
case 69:
#line 328 "../gram.y"
{ yyval = xxexprlist1(yyvsp[0], &@1); }
break;
case 70:
#line 329 "../gram.y"
{ yyval = xxexprlist2(yyvsp[-2], yyvsp[0], &@3); }
break;
case 71:
#line 330 "../gram.y"
{ yyval = yyvsp[-1]; }
break;
case 72:
#line 331 "../gram.y"
{ yyval = xxexprlist2(yyvsp[-2], yyvsp[0], &@3); }
break;
case 73:
#line 332 "../gram.y"
{ yyval = yyvsp[-1];}
break;
case 74:
#line 335 "../gram.y"
{ yyval = xxsublist1(yyvsp[0]); }
break;
case 75:
#line 336 "../gram.y"
{ yyval = xxsublist2(yyvsp[-3],yyvsp[0]); }
break;
case 76:
#line 339 "../gram.y"
{ yyval = xxsub0(); }
break;
case 77:
#line 340 "../gram.y"
{ yyval = xxsub1(yyvsp[0], &@1); }
break;
case 78:
#line 341 "../gram.y"
{ yyval = xxsymsub0(yyvsp[-1], &@1); }
break;
case 79:
#line 342 "../gram.y"
{ yyval = xxsymsub1(yyvsp[-2],yyvsp[0], &@1); }
break;
case 80:
#line 343 "../gram.y"
{ yyval = xxsymsub0(yyvsp[-1], &@1); }
break;
case 81:
#line 344 "../gram.y"
{ yyval = xxsymsub1(yyvsp[-2],yyvsp[0], &@1); }
break;
case 82:
#line 345 "../gram.y"
{ yyval = xxnullsub0(&@1); }
break;
case 83:
#line 346 "../gram.y"
{ yyval = xxnullsub1(yyvsp[0], &@1); }
break;
case 84:
#line 349 "../gram.y"
{ yyval = xxnullformal(); }
break;
case 85:
#line 350 "../gram.y"
{ yyval = xxfirstformal0(yyvsp[0]); }
break;
case 86:
#line 351 "../gram.y"
{ yyval = xxfirstformal1(yyvsp[-2],yyvsp[0]); }
break;
case 87:
#line 352 "../gram.y"
{ yyval = xxaddformal0(yyvsp[-2],yyvsp[0], &@3); }
break;
case 88:
#line 353 "../gram.y"
{ yyval = xxaddformal1(yyvsp[-4],yyvsp[-2],yyvsp[0],&@3); }
break;
case 89:
#line 356 "../gram.y"
{ EatLines = 1; }
break;
#line 3875 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yysslim && yygrowstack())
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;

yyoverflow:
    yyerror("yacc stack overflow");

yyabort:
    return (1);

yyaccept:
    return (0);
}
